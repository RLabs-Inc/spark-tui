---
phase: 02-theme-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.rs
  - src/theme/mod.rs
  - src/theme/presets.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Hex color strings can be parsed to Rgba"
    - "OKLCH color strings can be parsed to Rgba"
    - "Theme struct contains all semantic color slots"
    - "All 13 TypeScript presets are defined"
  artifacts:
    - path: "src/types.rs"
      provides: "Color parsing methods on Rgba"
      contains: "fn from_hex"
    - path: "src/theme/mod.rs"
      provides: "Theme module with ThemeColor type"
      exports: ["ThemeColor", "Theme", "themes"]
      min_lines: 100
    - path: "src/theme/presets.rs"
      provides: "13 theme preset definitions"
      contains: "DRACULA"
      min_lines: 200
  key_links:
    - from: "src/theme/mod.rs"
      to: "src/types.rs"
      via: "Rgba import"
      pattern: "use crate::types::Rgba"
---

<objective>
Create the theme module foundation with color parsing, Theme struct, and all 13 preset themes.

Purpose: Establish the data structures and preset definitions that the reactive theme system will build upon. This plan focuses on the static/type definitions, not reactivity.

Output: Working theme module with ThemeColor type, Theme struct containing all semantic colors, and 13 preset themes matching TypeScript exactly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-theme-system/02-CONTEXT.md

# Reference implementation
# TypeScript: /Users/rusty/Documents/Projects/TUI/tui/src/state/theme.ts
# TypeScript: /Users/rusty/Documents/Projects/TUI/tui/src/types/color.ts

# Existing Rust code
@src/types.rs
@src/state/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add color parsing to Rgba</name>
  <files>src/types.rs</files>
  <action>
    Add color parsing methods to the existing `Rgba` impl in `src/types.rs`:

    1. **Hex parsing**:
       ```rust
       /// Parse hex color string (#RGB, #RRGGBB, #RRGGBBAA)
       /// Returns None for invalid format.
       pub fn from_hex(hex: &str) -> Option<Self> {
           let hex = hex.trim_start_matches('#');
           match hex.len() {
               3 => { /* #RGB -> expand to #RRGGBB */ }
               6 => { /* #RRGGBB */ }
               8 => { /* #RRGGBBAA */ }
               _ => None,
           }
       }
       ```

    2. **OKLCH string parsing**:
       ```rust
       /// Parse OKLCH color string: "oklch(L C H)" or "oklch(L C H / A)"
       /// L: 0-1 (or 0%-100%), C: 0-0.4 roughly, H: 0-360 degrees
       pub fn from_oklch_str(s: &str) -> Option<Self> {
           // Parse "oklch(0.75 0.15 300)" format
           // Handle % for lightness
           // Handle optional alpha with "/"
       }
       ```

    3. **General color parsing**:
       ```rust
       /// Parse any supported color format.
       /// Supports: hex (#RGB, #RRGGBB), oklch(), integer (0xRRGGBB), "transparent"
       pub fn parse(input: &str) -> Option<Self> {
           let input = input.trim().to_lowercase();
           if input == "transparent" { return Some(Self::TRANSPARENT); }
           if input.starts_with('#') { return Self::from_hex(&input); }
           if input.starts_with("oklch(") { return Self::from_oklch_str(&input); }
           None
       }
       ```

    4. **From integer**:
       ```rust
       /// Create from 0xRRGGBB integer format.
       pub const fn from_rgb_int(rgb: u32) -> Self {
           Self::rgb(
               ((rgb >> 16) & 0xFF) as u8,
               ((rgb >> 8) & 0xFF) as u8,
               (rgb & 0xFF) as u8,
           )
       }
       ```

    Add comprehensive tests for all parsing functions.
  </action>
  <verify>
    `cargo test -p spark-tui rgba` passes all parsing tests.
    `Rgba::from_hex("#ff5500")` returns correct color.
    `Rgba::from_oklch_str("oklch(0.75 0.15 300)")` returns correct color.
  </verify>
  <done>
    Rgba::from_hex parses #RGB and #RRGGBB formats.
    Rgba::from_oklch_str parses OKLCH strings.
    Rgba::parse handles all formats.
    Tests cover edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create theme module with Theme struct</name>
  <files>src/theme/mod.rs, src/lib.rs</files>
  <action>
    Create `src/theme/mod.rs`:

    1. **ThemeColor type** (matches TypeScript):
       ```rust
       /// Theme color can be:
       /// - None: Terminal default
       /// - ANSI index (0-255)
       /// - RGB value
       /// - String (parsed on use)
       #[derive(Debug, Clone, PartialEq)]
       pub enum ThemeColor {
           /// Use terminal default color
           Default,
           /// ANSI palette index (0-255)
           Ansi(u8),
           /// RGB color
           Rgb(Rgba),
           /// String to be parsed (hex, oklch, etc.)
           Str(String),
       }

       impl ThemeColor {
           /// Resolve to Rgba. Parses string if needed.
           pub fn resolve(&self) -> Rgba {
               match self {
                   Self::Default => Rgba::TERMINAL_DEFAULT,
                   Self::Ansi(i) => Rgba::ansi(*i),
                   Self::Rgb(c) => *c,
                   Self::Str(s) => Rgba::parse(s).unwrap_or(Rgba::MAGENTA),
               }
           }
       }

       // Convenient From impls
       impl From<()> for ThemeColor { /* Default */ }
       impl From<u8> for ThemeColor { /* Ansi */ }
       impl From<Rgba> for ThemeColor { /* Rgb */ }
       impl From<&str> for ThemeColor { /* Str */ }
       impl From<u32> for ThemeColor { /* Rgb from int */ }
       ```

    2. **Theme struct** (all semantic colors):
       ```rust
       /// Theme definition with all semantic colors.
       #[derive(Debug, Clone)]
       pub struct Theme {
           pub name: String,
           pub description: String,

           // Main palette
           pub primary: ThemeColor,
           pub secondary: ThemeColor,
           pub tertiary: ThemeColor,
           pub accent: ThemeColor,

           // Semantic
           pub success: ThemeColor,
           pub warning: ThemeColor,
           pub error: ThemeColor,
           pub info: ThemeColor,

           // Text
           pub text: ThemeColor,
           pub text_muted: ThemeColor,
           pub text_dim: ThemeColor,
           pub text_disabled: ThemeColor,
           pub text_bright: ThemeColor,

           // Background
           pub background: ThemeColor,
           pub background_muted: ThemeColor,
           pub surface: ThemeColor,
           pub overlay: ThemeColor,

           // Border
           pub border: ThemeColor,
           pub border_focus: ThemeColor,
       }

       impl Default for Theme {
           fn default() -> Self {
               // Returns terminal preset
           }
       }
       ```

    3. **Module declaration** in theme/mod.rs:
       ```rust
       pub mod presets;
       pub use presets::*;
       ```

    Update `src/lib.rs`:
    - Add `pub mod theme;`
    - Add re-exports: `pub use theme::{ThemeColor, Theme};`
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `ThemeColor::from(12u8)` creates ANSI color.
    `ThemeColor::from("#ff5500")` creates string color.
  </verify>
  <done>
    ThemeColor enum with Default, Ansi, Rgb, Str variants.
    Theme struct with all 20 semantic color fields.
    From impls for ergonomic construction.
    Module exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create all 13 preset themes</name>
  <files>src/theme/presets.rs</files>
  <action>
    Create `src/theme/presets.rs` with all 13 presets from TypeScript:

    1. **Preset constants**:
       ```rust
       /// Terminal theme - uses ANSI colors to respect terminal's palette.
       pub const TERMINAL: Theme = Theme {
           name: "terminal",
           description: "Uses terminal default colors",
           primary: ThemeColor::Ansi(12),      // bright blue
           secondary: ThemeColor::Ansi(13),    // bright magenta
           tertiary: ThemeColor::Ansi(14),     // bright cyan
           accent: ThemeColor::Ansi(11),       // bright yellow
           success: ThemeColor::Ansi(2),       // green
           warning: ThemeColor::Ansi(3),       // yellow
           error: ThemeColor::Ansi(1),         // red
           info: ThemeColor::Ansi(6),          // cyan
           text: ThemeColor::Default,
           text_muted: ThemeColor::Ansi(8),
           text_dim: ThemeColor::Ansi(8),
           text_disabled: ThemeColor::Ansi(8),
           text_bright: ThemeColor::Ansi(15),
           background: ThemeColor::Default,
           background_muted: ThemeColor::Default,
           surface: ThemeColor::Default,
           overlay: ThemeColor::Default,
           border: ThemeColor::Ansi(7),
           border_focus: ThemeColor::Ansi(12),
       };

       /// Dracula - dark theme with vivid colors.
       pub const DRACULA: Theme = Theme { ... };

       /// Nord - arctic, bluish colors.
       pub const NORD: Theme = Theme { ... };

       // Continue for all 13:
       // - monokai
       // - solarized
       // - catppuccin (Mocha)
       // - gruvbox
       // - tokyoNight
       // - oneDark
       // - rosePine
       // - kanagawa
       // - everforest
       // - nightOwl
       ```

    2. **Preset lookup**:
       ```rust
       /// Get a preset by name.
       pub fn get_preset(name: &str) -> Option<&'static Theme> {
           match name.to_lowercase().as_str() {
               "terminal" => Some(&TERMINAL),
               "dracula" => Some(&DRACULA),
               "nord" => Some(&NORD),
               "monokai" => Some(&MONOKAI),
               "solarized" => Some(&SOLARIZED),
               "catppuccin" => Some(&CATPPUCCIN),
               "gruvbox" => Some(&GRUVBOX),
               "tokyonight" | "tokyo_night" => Some(&TOKYO_NIGHT),
               "onedark" | "one_dark" => Some(&ONE_DARK),
               "rosepine" | "rose_pine" => Some(&ROSE_PINE),
               "kanagawa" => Some(&KANAGAWA),
               "everforest" => Some(&EVERFOREST),
               "nightowl" | "night_owl" => Some(&NIGHT_OWL),
               _ => None,
           }
       }

       /// List all available preset names.
       pub fn preset_names() -> &'static [&'static str] {
           &["terminal", "dracula", "nord", "monokai", "solarized",
             "catppuccin", "gruvbox", "tokyoNight", "oneDark",
             "rosePine", "kanagawa", "everforest", "nightOwl"]
       }
       ```

    **IMPORTANT:** Copy exact color values from TypeScript theme.ts. For OKLCH colors
    in TypeScript like `'oklch(0.75 0.15 300)'`, use `ThemeColor::Str("oklch(0.75 0.15 300)")`.
    For hex integers like `0xf8f8f2`, use `ThemeColor::Rgb(Rgba::from_rgb_int(0xf8f8f2))`.

    Note: Since Theme has String fields, we cannot use `const` for all presets.
    Use `lazy_static!` or make them functions that return owned Theme:

    ```rust
    pub fn terminal() -> Theme { ... }
    pub fn dracula() -> Theme { ... }
    ```

    Or use Cow<'static, str> for name/description to enable const.
  </action>
  <verify>
    `cargo test -p spark-tui presets` passes.
    `get_preset("dracula")` returns Dracula theme.
    All 13 presets have correct colors matching TypeScript.
  </verify>
  <done>
    All 13 presets defined with correct colors.
    get_preset() provides name-based lookup.
    preset_names() returns list of available presets.
    Tests verify color values match TypeScript.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify: `use spark_tui::theme::{ThemeColor, Theme, get_preset};`
4. Verify: `get_preset("dracula").primary.resolve()` returns correct purple
5. Verify: All 13 presets accessible
</verification>

<success_criteria>
- Rgba::from_hex parses hex strings correctly
- Rgba::from_oklch_str parses OKLCH strings correctly
- ThemeColor enum supports Default, Ansi, Rgb, Str variants
- Theme struct has all 20 semantic color fields
- All 13 TypeScript presets are defined with matching colors
- get_preset() returns preset by name
- Tests validate color parsing and preset definitions
</success_criteria>

<output>
After completion, create `.planning/phases/02-theme-system/02-01-SUMMARY.md`
</output>
