---
phase: 02-theme-system
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/theme/modifiers.rs
  - src/theme/accessor.rs
  - src/theme/mod.rs
autonomous: true

must_haves:
  truths:
    - "Color modifiers (lighten, darken, alpha) work on Rgba"
    - "t.contrast(bg) returns color with sufficient contrast"
    - "Modifiers are chainable"
    - "All modifiers preserve reactivity when used with theme colors"
  artifacts:
    - path: "src/theme/modifiers.rs"
      provides: "Color modification functions"
      exports: ["lighten", "darken", "saturate", "desaturate", "alpha", "mix"]
      min_lines: 80
    - path: "src/theme/accessor.rs"
      provides: "contrast method on ThemeAccessor"
      contains: "fn contrast"
  key_links:
    - from: "src/theme/modifiers.rs"
      to: "src/types.rs"
      via: "Rgba OKLCH methods"
      pattern: "to_oklch|oklch"
---

<objective>
Create color manipulation functions and the t.contrast() method for automatic contrast calculation.

Purpose: Enable ergonomic color manipulation (lighten, darken, alpha, etc.) and automatic contrast calculation that matches TypeScript's color manipulation API. This completes the theme system's color utilities.

Output: Color modifier functions, contrast calculation on ThemeAccessor, and comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-theme-system/02-CONTEXT.md
@.planning/phases/02-theme-system/02-02-SUMMARY.md

# Reference implementation
# TypeScript: /Users/rusty/Documents/Projects/TUI/tui/src/types/color.ts

# Rust modules
@src/types.rs (Rgba with OKLCH support)
@src/theme/accessor.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create color modifier functions</name>
  <files>src/theme/modifiers.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/modifiers.rs` with color manipulation:

    1. **Lightness modifiers**:
       ```rust
       use crate::Rgba;

       /// Lighten a color by adjusting OKLCH lightness.
       /// Amount is 0.0-1.0 where 0.2 = 20% lighter.
       /// Returns original for ANSI/terminal default colors.
       pub fn lighten(color: Rgba, amount: f32) -> Rgba {
           color.adjust_lightness(amount).unwrap_or(color)
       }

       /// Darken a color by adjusting OKLCH lightness.
       /// Amount is 0.0-1.0 where 0.2 = 20% darker.
       pub fn darken(color: Rgba, amount: f32) -> Rgba {
           color.adjust_lightness(-amount).unwrap_or(color)
       }
       ```

    2. **Saturation modifiers**:
       ```rust
       /// Increase color saturation (chroma) by amount.
       /// Amount is added to current chroma (typical range 0.0-0.4).
       pub fn saturate(color: Rgba, amount: f32) -> Rgba {
           if let Some((l, c, h)) = color.to_oklch() {
               let new_c = (c + amount).clamp(0.0, 0.5);
               Rgba::oklch(l, new_c, h, color.a as u8)
           } else {
               color
           }
       }

       /// Decrease color saturation (chroma) by amount.
       pub fn desaturate(color: Rgba, amount: f32) -> Rgba {
           if let Some((l, c, h)) = color.to_oklch() {
               let new_c = (c - amount).max(0.0);
               Rgba::oklch(l, new_c, h, color.a as u8)
           } else {
               color
           }
       }
       ```

    3. **Alpha modifier**:
       ```rust
       /// Set alpha value (0-255 or 0.0-1.0).
       /// If value <= 1.0, treat as fraction; else as 0-255.
       pub fn alpha(color: Rgba, value: f32) -> Rgba {
           let a = if value <= 1.0 {
               (value * 255.0) as i16
           } else {
               value as i16
           };
           Rgba {
               a: a.clamp(0, 255),
               ..color
           }
       }

       /// Multiply alpha by a factor (0.0-1.0).
       pub fn fade(color: Rgba, factor: f32) -> Rgba {
           let new_a = (color.a as f32 * factor) as i16;
           Rgba {
               a: new_a.clamp(0, 255),
               ..color
           }
       }
       ```

    4. **Color mixing**:
       ```rust
       /// Mix two colors. Weight 0.0 = first, 1.0 = second, 0.5 = equal.
       pub fn mix(a: Rgba, b: Rgba, weight: f32) -> Rgba {
           Rgba::lerp(a, b, weight)
       }
       ```

    5. **Contrast calculation**:
       ```rust
       /// Adjust color to have minimum contrast against background.
       /// Uses OKLCH to preserve hue while adjusting lightness.
       /// Target defaults to WCAG AA (4.5:1).
       pub fn contrast(fg: Rgba, bg: Rgba, min_ratio: f32) -> Rgba {
           Rgba::ensure_contrast(fg, bg, min_ratio).unwrap_or(fg)
       }

       /// Convenience for WCAG AA contrast (4.5:1).
       pub fn contrast_aa(fg: Rgba, bg: Rgba) -> Rgba {
           contrast(fg, bg, 4.5)
       }

       /// Convenience for WCAG AAA contrast (7:1).
       pub fn contrast_aaa(fg: Rgba, bg: Rgba) -> Rgba {
           contrast(fg, bg, 7.0)
       }
       ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod modifiers;
    pub use modifiers::*;
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `lighten(Rgba::rgb(100, 100, 100), 0.2)` returns lighter color.
    `alpha(Rgba::RED, 0.5)` returns color with a=127.
  </verify>
  <done>
    lighten/darken adjust OKLCH lightness.
    saturate/desaturate adjust OKLCH chroma.
    alpha/fade modify alpha channel.
    mix blends two colors.
    contrast ensures minimum contrast ratio.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add contrast method to ThemeAccessor</name>
  <files>src/theme/accessor.rs</files>
  <action>
    Add contrast calculation to ThemeAccessor:

    1. **Add contrast method**:
       ```rust
       impl ThemeAccessor {
           // ... existing new() and fields ...

           /// Get a color that contrasts well against the given background.
           /// Uses the primary theme color as base, adjusts for contrast.
           ///
           /// # Usage
           /// ```
           /// let bg = t().surface.get();
           /// let fg = t().contrast(bg); // Good contrast against surface
           /// ```
           pub fn contrast(&self, bg: Rgba) -> Rgba {
               let fg = self.text.get();
               super::modifiers::contrast(fg, bg, 4.5)
           }

           /// Get a specific theme color adjusted for contrast against background.
           ///
           /// # Usage
           /// ```
           /// let bg = my_custom_bg;
           /// let fg = t().contrast_with(t().primary.get(), bg);
           /// ```
           pub fn contrast_with(&self, fg: Rgba, bg: Rgba) -> Rgba {
               super::modifiers::contrast(fg, bg, 4.5)
           }
       }
       ```

    2. **Add chainable modifier helpers** (optional, for ergonomics):
       ```rust
       /// Color wrapper that enables chaining modifiers.
       pub struct ModifiableColor(pub Rgba);

       impl ModifiableColor {
           pub fn lighten(self, amount: f32) -> Self {
               Self(super::modifiers::lighten(self.0, amount))
           }

           pub fn darken(self, amount: f32) -> Self {
               Self(super::modifiers::darken(self.0, amount))
           }

           pub fn alpha(self, value: f32) -> Self {
               Self(super::modifiers::alpha(self.0, value))
           }

           pub fn saturate(self, amount: f32) -> Self {
               Self(super::modifiers::saturate(self.0, amount))
           }

           pub fn desaturate(self, amount: f32) -> Self {
               Self(super::modifiers::desaturate(self.0, amount))
           }

           pub fn contrast(self, bg: Rgba) -> Self {
               Self(super::modifiers::contrast(self.0, bg, 4.5))
           }

           pub fn get(self) -> Rgba {
               self.0
           }
       }

       impl From<Rgba> for ModifiableColor {
           fn from(c: Rgba) -> Self {
               Self(c)
           }
       }

       impl From<ModifiableColor> for Rgba {
           fn from(c: ModifiableColor) -> Self {
               c.0
           }
       }
       ```

    3. **Usage pattern**:
       ```rust
       // Direct use
       let bg = darken(t().surface.get(), 0.1);

       // With ModifiableColor chaining
       let fg = ModifiableColor::from(t().primary.get())
           .lighten(0.1)
           .alpha(0.8)
           .get();

       // Contrast
       let text_color = t().contrast(dark_background);
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `t().contrast(Rgba::BLACK)` returns light color.
    `ModifiableColor::from(Rgba::RED).lighten(0.2).get()` returns lighter red.
  </verify>
  <done>
    ThemeAccessor has contrast() method.
    ThemeAccessor has contrast_with() for any fg/bg.
    ModifiableColor enables chaining modifiers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for all modifiers</name>
  <files>src/theme/modifiers.rs, src/theme/accessor.rs</files>
  <action>
    Add comprehensive tests:

    1. **Tests in modifiers.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;

           #[test]
           fn test_lighten() {
               let color = Rgba::rgb(100, 100, 100);
               let lighter = lighten(color, 0.2);

               // Should be brighter (higher RGB values on average)
               let avg_before = (color.r + color.g + color.b) / 3;
               let avg_after = (lighter.r + lighter.g + lighter.b) / 3;
               assert!(avg_after > avg_before);
           }

           #[test]
           fn test_darken() {
               let color = Rgba::rgb(150, 150, 150);
               let darker = darken(color, 0.2);

               let avg_before = (color.r + color.g + color.b) / 3;
               let avg_after = (darker.r + darker.g + darker.b) / 3;
               assert!(avg_after < avg_before);
           }

           #[test]
           fn test_lighten_ansi_returns_original() {
               let ansi = Rgba::ansi(4);
               let result = lighten(ansi, 0.2);
               assert_eq!(result, ansi);
           }

           #[test]
           fn test_alpha_fraction() {
               let color = Rgba::RED;
               let transparent = alpha(color, 0.5);
               assert_eq!(transparent.a, 127);
           }

           #[test]
           fn test_alpha_absolute() {
               let color = Rgba::RED;
               let result = alpha(color, 200.0);
               assert_eq!(result.a, 200);
           }

           #[test]
           fn test_fade() {
               let color = Rgba::new(100, 100, 100, 200);
               let faded = fade(color, 0.5);
               assert_eq!(faded.a, 100);
           }

           #[test]
           fn test_saturate() {
               let gray = Rgba::rgb(128, 128, 128);
               let saturated = saturate(gray, 0.1);
               // Gray has 0 chroma, adding some should create color
               // May still look grayish but chroma increased
               let (_, c_before, _) = gray.to_oklch().unwrap();
               let (_, c_after, _) = saturated.to_oklch().unwrap();
               assert!(c_after > c_before);
           }

           #[test]
           fn test_desaturate() {
               let color = Rgba::rgb(255, 0, 0); // Pure red, high chroma
               let desat = desaturate(color, 0.1);
               let (_, c_before, _) = color.to_oklch().unwrap();
               let (_, c_after, _) = desat.to_oklch().unwrap();
               assert!(c_after < c_before);
           }

           #[test]
           fn test_mix_equal() {
               let a = Rgba::BLACK;
               let b = Rgba::WHITE;
               let mixed = mix(a, b, 0.5);
               // Should be gray
               assert!((mixed.r - 127).abs() <= 1);
               assert!((mixed.g - 127).abs() <= 1);
               assert!((mixed.b - 127).abs() <= 1);
           }

           #[test]
           fn test_contrast_dark_on_dark() {
               let dark_bg = Rgba::rgb(30, 30, 30);
               let dark_fg = Rgba::rgb(50, 50, 50);
               let adjusted = contrast(dark_fg, dark_bg, 4.5);

               let ratio = Rgba::contrast_ratio(adjusted, dark_bg);
               assert!(ratio >= 4.5, "Ratio {} should be >= 4.5", ratio);
           }

           #[test]
           fn test_contrast_light_on_light() {
               let light_bg = Rgba::rgb(230, 230, 230);
               let light_fg = Rgba::rgb(200, 200, 200);
               let adjusted = contrast(light_fg, light_bg, 4.5);

               let ratio = Rgba::contrast_ratio(adjusted, light_bg);
               assert!(ratio >= 4.5, "Ratio {} should be >= 4.5", ratio);
           }

           #[test]
           fn test_contrast_already_good() {
               let bg = Rgba::BLACK;
               let fg = Rgba::WHITE;
               let adjusted = contrast(fg, bg, 4.5);
               // Already has 21:1 contrast, should not change much
               assert_eq!(adjusted.r, fg.r);
           }
       }
       ```

    2. **Tests in accessor.rs**:
       ```rust
       #[test]
       fn test_theme_accessor_contrast() {
           reset_theme_state();
           let accessor = t();
           let bg = Rgba::rgb(20, 20, 20); // Very dark
           let fg = accessor.contrast(bg);

           let ratio = Rgba::contrast_ratio(fg, bg);
           assert!(ratio >= 4.5);
       }

       #[test]
       fn test_modifiable_color_chaining() {
           let result = ModifiableColor::from(Rgba::rgb(100, 50, 50))
               .lighten(0.1)
               .alpha(0.8)
               .get();

           // Should be lighter and semi-transparent
           assert!(result.r > 100);
           assert!(result.a < 255);
       }
       ```
  </action>
  <verify>
    `cargo test -p spark-tui modifiers -- --test-threads=1` passes.
    `cargo test -p spark-tui accessor -- --test-threads=1` passes.
    All modifier functions tested.
  </verify>
  <done>
    Tests for lighten, darken with RGB colors.
    Tests verify ANSI colors return unchanged.
    Tests for alpha, fade, saturate, desaturate.
    Tests for mix blending.
    Tests for contrast ensuring minimum ratio.
    Tests for ModifiableColor chaining.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify: `lighten(Rgba::RED, 0.2)` returns lighter red
4. Verify: `t().contrast(dark_bg)` returns readable text color
5. Verify: Chaining works with ModifiableColor
</verification>

<success_criteria>
- lighten/darken adjust OKLCH lightness correctly
- saturate/desaturate adjust OKLCH chroma correctly
- alpha sets alpha, fade multiplies alpha
- mix blends two colors
- contrast ensures minimum contrast ratio
- ANSI colors return unchanged from modifiers
- ThemeAccessor has contrast() method
- ModifiableColor enables chaining
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-theme-system/02-04-SUMMARY.md`
</output>
