---
phase: 02-theme-system
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/theme/variant.rs
  - src/theme/mod.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Variant enum covers all 14 TypeScript variants"
    - "get_variant_style returns fg, bg, border, border_focus"
    - "Variant colors respect current theme"
    - "Contrast is calculated for RGB themes"
  artifacts:
    - path: "src/theme/variant.rs"
      provides: "Variant enum and style calculation"
      exports: ["Variant", "VariantStyle", "get_variant_style", "variant_style"]
      min_lines: 150
  key_links:
    - from: "src/theme/variant.rs"
      to: "src/theme/reactive.rs"
      via: "resolved_theme import"
      pattern: "resolved_theme\\(\\)"
    - from: "src/theme/variant.rs"
      to: "src/types.rs"
      via: "Rgba::ensure_contrast"
      pattern: "ensure_contrast"
---

<objective>
Create the variant system for consistent component theming with automatic contrast calculation.

Purpose: Enable components to use semantic variants (primary, success, error, etc.) that automatically calculate proper foreground/background colors with WCAG-compliant contrast. This matches TypeScript's getVariantStyle() functionality.

Output: Variant enum, VariantStyle struct, get_variant_style() function, and reactive variant_style() derived.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-theme-system/02-CONTEXT.md
@.planning/phases/02-theme-system/02-01-SUMMARY.md
@.planning/phases/02-theme-system/02-02-SUMMARY.md

# Reference implementation
# TypeScript: /Users/rusty/Documents/Projects/TUI/tui/src/state/theme.ts (lines 775-937 for variants)

# Rust modules
@src/theme/mod.rs
@src/theme/reactive.rs
@src/types.rs (for Rgba::ensure_contrast)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Variant enum and VariantStyle</name>
  <files>src/theme/variant.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/variant.rs`:

    1. **Variant enum** (all 14 from TypeScript):
       ```rust
       /// Semantic variants for component theming.
       /// Each variant defines a consistent color scheme.
       #[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
       pub enum Variant {
           /// Default styling (text on background)
           #[default]
           Default,

           /// Primary action/emphasis
           Primary,
           /// Secondary action
           Secondary,
           /// Tertiary action
           Tertiary,
           /// Accent/highlight
           Accent,

           /// Success state (green)
           Success,
           /// Warning state (yellow/orange)
           Warning,
           /// Error state (red)
           Error,
           /// Informational state (blue/cyan)
           Info,

           /// Muted/subtle styling
           Muted,
           /// Surface/card styling
           Surface,
           /// Elevated surface (more contrast)
           Elevated,

           /// Ghost - transparent background
           Ghost,
           /// Outline - border only, transparent bg
           Outline,
       }

       impl Variant {
           /// Parse from string (case-insensitive).
           pub fn from_str(s: &str) -> Option<Self> {
               match s.to_lowercase().as_str() {
                   "default" => Some(Self::Default),
                   "primary" => Some(Self::Primary),
                   "secondary" => Some(Self::Secondary),
                   "tertiary" => Some(Self::Tertiary),
                   "accent" => Some(Self::Accent),
                   "success" => Some(Self::Success),
                   "warning" => Some(Self::Warning),
                   "error" => Some(Self::Error),
                   "info" => Some(Self::Info),
                   "muted" => Some(Self::Muted),
                   "surface" => Some(Self::Surface),
                   "elevated" => Some(Self::Elevated),
                   "ghost" => Some(Self::Ghost),
                   "outline" => Some(Self::Outline),
                   _ => None,
               }
           }
       }
       ```

    2. **VariantStyle struct**:
       ```rust
       /// Resolved colors for a variant.
       #[derive(Debug, Clone, Copy, PartialEq)]
       pub struct VariantStyle {
           /// Foreground (text) color
           pub fg: Rgba,
           /// Background color
           pub bg: Rgba,
           /// Border color
           pub border: Rgba,
           /// Border color when focused
           pub border_focus: Rgba,
       }
       ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod variant;
    pub use variant::{Variant, VariantStyle};
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `Variant::Primary` exists.
    `Variant::from_str("success")` returns `Some(Variant::Success)`.
  </verify>
  <done>
    Variant enum with all 14 variants.
    VariantStyle struct with fg, bg, border, border_focus.
    Variant::from_str for string parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement get_variant_style with contrast</name>
  <files>src/theme/variant.rs</files>
  <action>
    Add variant style calculation to `src/theme/variant.rs`:

    1. **Contrast helper** (internal):
       ```rust
       use crate::Rgba;
       use super::reactive::resolved_theme;

       /// Get a foreground color with proper contrast against background.
       /// For ANSI colors: trust terminal's handling.
       /// For RGB colors: adjust lightness using OKLCH for WCAG AA (4.5:1).
       fn get_contrast_fg(desired_fg: Rgba, bg: Rgba) -> Rgba {
           // If background is ANSI, trust terminal
           if bg.is_ansi() {
               return desired_fg;
           }

           // If foreground is ANSI but background is RGB, trust it
           if desired_fg.is_ansi() {
               return desired_fg;
           }

           // Both are RGB - ensure proper contrast
           Rgba::ensure_contrast(desired_fg, bg, 4.5).unwrap_or(desired_fg)
       }
       ```

    2. **get_variant_style function**:
       ```rust
       /// Get colors for a variant based on current theme.
       /// Automatically calculates contrast for RGB themes.
       pub fn get_variant_style(variant: Variant) -> VariantStyle {
           let theme = resolved_theme();

           match variant {
               Variant::Primary => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.primary),
                   bg: theme.primary,
                   border: theme.primary,
                   border_focus: theme.accent,
               },

               Variant::Secondary => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.secondary),
                   bg: theme.secondary,
                   border: theme.secondary,
                   border_focus: theme.accent,
               },

               Variant::Tertiary => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.tertiary),
                   bg: theme.tertiary,
                   border: theme.tertiary,
                   border_focus: theme.accent,
               },

               Variant::Accent => VariantStyle {
                   // Accent is often bright (yellow), need dark fg
                   fg: get_contrast_fg(Rgba::BLACK, theme.accent),
                   bg: theme.accent,
                   border: theme.accent,
                   border_focus: theme.primary,
               },

               Variant::Success => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.success),
                   bg: theme.success,
                   border: theme.success,
                   border_focus: theme.accent,
               },

               Variant::Warning => VariantStyle {
                   // Warning is often yellow, need dark fg
                   fg: get_contrast_fg(Rgba::BLACK, theme.warning),
                   bg: theme.warning,
                   border: theme.warning,
                   border_focus: theme.accent,
               },

               Variant::Error => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.error),
                   bg: theme.error,
                   border: theme.error,
                   border_focus: theme.accent,
               },

               Variant::Info => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.info),
                   bg: theme.info,
                   border: theme.info,
                   border_focus: theme.accent,
               },

               Variant::Muted => VariantStyle {
                   fg: theme.text_muted,
                   bg: theme.surface,
                   border: theme.border,
                   border_focus: theme.border_focus,
               },

               Variant::Surface => VariantStyle {
                   fg: theme.text,
                   bg: theme.surface,
                   border: theme.border,
                   border_focus: theme.border_focus,
               },

               Variant::Elevated => VariantStyle {
                   fg: get_contrast_fg(theme.text_bright, theme.surface),
                   bg: theme.surface,
                   border: theme.primary,
                   border_focus: theme.border_focus,
               },

               Variant::Ghost => VariantStyle {
                   fg: theme.text,
                   bg: Rgba::TERMINAL_DEFAULT,
                   border: Rgba::TERMINAL_DEFAULT,
                   border_focus: theme.border_focus,
               },

               Variant::Outline => VariantStyle {
                   fg: theme.primary,
                   bg: Rgba::TERMINAL_DEFAULT,
                   border: theme.primary,
                   border_focus: theme.border_focus,
               },

               Variant::Default => VariantStyle {
                   fg: theme.text,
                   bg: theme.background,
                   border: theme.border,
                   border_focus: theme.border_focus,
               },
           }
       }
       ```

    3. **Reactive variant_style derived**:
       ```rust
       use spark_signals::{derived, Derived};

       /// Get reactive variant style that updates when theme changes.
       pub fn variant_style(variant: Variant) -> Derived<VariantStyle> {
           derived(move || get_variant_style(variant))
       }
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `get_variant_style(Variant::Primary)` returns style with theme colors.
    `variant_style(Variant::Error)` returns a Derived.
  </verify>
  <done>
    get_contrast_fg calculates proper contrast.
    get_variant_style returns VariantStyle for all 14 variants.
    variant_style returns reactive Derived<VariantStyle>.
    Colors match TypeScript implementation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and update exports</name>
  <files>src/theme/variant.rs, src/theme/mod.rs, src/lib.rs</files>
  <action>
    1. **Tests in variant.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;
           use crate::theme::{set_theme, reset_theme_state};

           #[test]
           fn test_variant_from_str() {
               assert_eq!(Variant::from_str("primary"), Some(Variant::Primary));
               assert_eq!(Variant::from_str("SUCCESS"), Some(Variant::Success));
               assert_eq!(Variant::from_str("invalid"), None);
           }

           #[test]
           fn test_variant_style_terminal_theme() {
               reset_theme_state();
               let style = get_variant_style(Variant::Primary);
               // Terminal theme uses ANSI colors
               assert!(style.bg.is_ansi());
           }

           #[test]
           fn test_variant_style_rgb_theme() {
               reset_theme_state();
               set_theme("dracula");
               let style = get_variant_style(Variant::Primary);
               // Dracula uses RGB colors
               assert!(!style.bg.is_ansi());
               assert!(!style.bg.is_terminal_default());
           }

           #[test]
           fn test_variant_style_contrast() {
               reset_theme_state();
               set_theme("dracula");
               let style = get_variant_style(Variant::Warning);
               // Warning bg is bright, fg should have good contrast
               let ratio = Rgba::contrast_ratio(style.fg, style.bg);
               assert!(ratio >= 4.5, "Contrast ratio {} should be >= 4.5", ratio);
           }

           #[test]
           fn test_all_variants_have_styles() {
               reset_theme_state();
               let variants = [
                   Variant::Default, Variant::Primary, Variant::Secondary,
                   Variant::Tertiary, Variant::Accent, Variant::Success,
                   Variant::Warning, Variant::Error, Variant::Info,
                   Variant::Muted, Variant::Surface, Variant::Elevated,
                   Variant::Ghost, Variant::Outline,
               ];
               for v in variants {
                   let style = get_variant_style(v);
                   // Should not panic, should return valid style
                   assert!(style.fg != Rgba::default() || style.bg != Rgba::default());
               }
           }

           #[test]
           fn test_variant_style_reactive() {
               reset_theme_state();
               let style_derived = variant_style(Variant::Primary);
               let initial = style_derived.get();

               set_theme("nord");
               let after = style_derived.get();

               // Style should change with theme
               assert_ne!(initial.bg, after.bg);
           }
       }
       ```

    2. **Update mod.rs exports**:
       ```rust
       // In src/theme/mod.rs
       pub use variant::{Variant, VariantStyle, get_variant_style, variant_style};
       ```

    3. **Update lib.rs re-exports**:
       ```rust
       // In src/lib.rs
       pub use theme::{
           // Types
           ThemeColor, Theme, Variant, VariantStyle,
           // Presets
           get_preset, preset_names,
           // Reactive
           active_theme, set_theme, set_custom_theme, resolved_theme, t,
           // Variants
           get_variant_style, variant_style,
       };
       ```
  </action>
  <verify>
    `cargo test -p spark-tui variant -- --test-threads=1` passes all tests.
    `cargo test -p spark-tui theme -- --test-threads=1` passes all tests.
    All variant-related types exported from spark_tui.
  </verify>
  <done>
    Tests cover all variants.
    Tests verify contrast calculation.
    Tests verify reactivity.
    All public API exported from lib.rs.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify: `get_variant_style(Variant::Primary)` returns themed colors
4. Verify: `variant_style(Variant::Error).get()` updates when theme changes
5. Verify: RGB themes have proper contrast (4.5:1 ratio)
</verification>

<success_criteria>
- Variant enum has all 14 variants
- VariantStyle has fg, bg, border, border_focus fields
- get_variant_style returns correct colors for each variant
- Contrast is calculated automatically for RGB themes
- ANSI themes trust terminal's contrast handling
- variant_style() returns reactive Derived
- All public API properly exported
- Tests verify all variants and contrast calculation
</success_criteria>

<output>
After completion, create `.planning/phases/02-theme-system/02-03-SUMMARY.md`
</output>
