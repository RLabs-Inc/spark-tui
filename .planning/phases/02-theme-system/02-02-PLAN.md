---
phase: 02-theme-system
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - Cargo.toml
  - src/theme/mod.rs
  - src/theme/reactive.rs
  - src/theme/accessor.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Theme uses #[derive(Reactive)] for fine-grained reactivity"
    - "Changing one color only notifies deriveds reading that color"
    - "t.primary returns Derived<Rgba> tracking only primary signal"
    - "set_theme() copies preset values to ReactiveTheme fields"
  artifacts:
    - path: "Cargo.toml"
      provides: "spark-signals from crates.io (derive is default)"
      contains: 'spark-signals = "0.1.0"'
    - path: "src/theme/mod.rs"
      provides: "Theme with #[derive(Reactive)]"
      contains: "#[derive(Reactive)]"
    - path: "src/theme/reactive.rs"
      provides: "Reactive theme state using ReactiveTheme"
      exports: ["active_theme", "set_theme", "reset_theme_state"]
      min_lines: 80
    - path: "src/theme/accessor.rs"
      provides: "t accessor struct with fine-grained deriveds"
      exports: ["t", "ThemeAccessor"]
      min_lines: 100
  key_links:
    - from: "src/theme/accessor.rs"
      to: "src/theme/reactive.rs"
      via: "active_theme dependency"
      pattern: "ACTIVE_THEME"
    - from: "src/theme/mod.rs"
      to: "spark_signals"
      via: "Reactive derive"
      pattern: "use spark_signals::Reactive"
---

<objective>
Create the reactive theme system using #[derive(Reactive)] for fine-grained per-color reactivity.

Purpose: Enable fully reactive theming where changing ONE color only notifies components that use THAT color. This is better than Signal<Theme> which would notify ALL components on any change.

Key insight: spark-signals has #[derive(Reactive)] which generates ReactiveTheme where each field becomes Signal<T>. Changing active_theme.primary only notifies deriveds reading primary, not secondary/tertiary/etc.

Output: ReactiveTheme as active state, set_theme() that copies preset colors, and t.* accessor returning deriveds with fine-grained tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-theme-system/02-CONTEXT.md
@.planning/phases/02-theme-system/02-01-SUMMARY.md

# Reference: spark-signals derive macro
# /Users/rusty/Documents/Projects/TUI/tui-rust/crates/signals/signals-derive/src/lib.rs

# Rust modules
@src/theme/mod.rs
@src/theme/presets.rs
@src/state/keyboard.rs (for thread_local! pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable derive feature and add Reactive to Theme</name>
  <files>Cargo.toml, src/theme/mod.rs</files>
  <action>
    1. **Update Cargo.toml** to use published crate (derive is default):
       ```toml
       spark-signals = "0.1.0"
       ```

    2. **Add #[derive(Reactive)] to Theme** in `src/theme/mod.rs`:
       ```rust
       use spark_signals::Reactive;

       /// Theme definition with all semantic colors.
       ///
       /// The #[derive(Reactive)] macro generates `ReactiveTheme` where each field
       /// becomes a Signal<T>. This enables fine-grained reactivity - changing one
       /// color only notifies deriveds reading that specific color.
       #[derive(Debug, Clone, Reactive)]
       pub struct Theme {
           // ... existing fields unchanged ...
       }
       ```

       This generates:
       ```rust
       pub struct ReactiveTheme {
           pub name: Signal<String>,
           pub description: Signal<String>,
           pub primary: Signal<ThemeColor>,
           pub secondary: Signal<ThemeColor>,
           // ... all 20 color fields as Signal<ThemeColor>
       }

       impl ReactiveTheme {
           pub fn new(name: String, description: String, ...) -> Self;
           pub fn from_original(theme: Theme) -> Self;
           pub fn to_snapshot(&self) -> Theme;
       }

       pub fn reactive_theme(...) -> ReactiveTheme;
       ```

    3. **Re-export ReactiveTheme** from mod.rs:
       ```rust
       // ReactiveTheme is auto-generated by #[derive(Reactive)]
       // It's already in scope, just document it
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `ReactiveTheme::from_original(terminal())` creates reactive version.
  </verify>
  <done>
    spark-signals derive feature enabled.
    Theme has #[derive(Reactive)] generating ReactiveTheme.
    Each ThemeColor field becomes Signal<ThemeColor>.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reactive theme state with ReactiveTheme</name>
  <files>src/theme/reactive.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/reactive.rs` with ReactiveTheme-based state:

    ```rust
    //! Reactive theme state management.
    //!
    //! Uses ReactiveTheme (generated by #[derive(Reactive)]) for fine-grained
    //! per-color reactivity. Changing one color only notifies deriveds that
    //! read that specific color.

    use std::cell::RefCell;
    use super::{Theme, ReactiveTheme, ThemeColor, get_preset, terminal};
    use crate::types::Rgba;

    thread_local! {
        /// The active theme - each field is a Signal<ThemeColor>.
        /// Fine-grained: changing primary only notifies primary dependents.
        static ACTIVE_THEME: RefCell<ReactiveTheme> = RefCell::new(
            ReactiveTheme::from_original(terminal())
        );
    }

    /// Get a snapshot of the current theme (non-reactive).
    pub fn active_theme() -> Theme {
        ACTIVE_THEME.with(|t| t.borrow().to_snapshot())
    }

    /// Get the reactive theme for creating deriveds.
    /// Returns a clone of ReactiveTheme (Signal clones are cheap).
    pub fn reactive_theme() -> ReactiveTheme {
        ACTIVE_THEME.with(|t| t.borrow().clone())
    }

    /// Set the active theme by preset name.
    /// Copies each color from preset to the reactive signals.
    pub fn set_theme(name: &str) {
        if let Some(preset) = get_preset(name) {
            set_theme_from(preset);
        }
    }

    /// Set a custom theme.
    pub fn set_custom_theme(theme: Theme) {
        set_theme_from(theme);
    }

    /// Internal: copy theme values to ReactiveTheme signals.
    fn set_theme_from(theme: Theme) {
        ACTIVE_THEME.with(|t| {
            let rt = t.borrow();
            rt.name.set(theme.name);
            rt.description.set(theme.description);
            rt.primary.set(theme.primary);
            rt.secondary.set(theme.secondary);
            rt.tertiary.set(theme.tertiary);
            rt.accent.set(theme.accent);
            rt.success.set(theme.success);
            rt.warning.set(theme.warning);
            rt.error.set(theme.error);
            rt.info.set(theme.info);
            rt.text.set(theme.text);
            rt.text_muted.set(theme.text_muted);
            rt.text_dim.set(theme.text_dim);
            rt.text_disabled.set(theme.text_disabled);
            rt.text_bright.set(theme.text_bright);
            rt.background.set(theme.background);
            rt.background_muted.set(theme.background_muted);
            rt.surface.set(theme.surface);
            rt.overlay.set(theme.overlay);
            rt.border.set(theme.border);
            rt.border_focus.set(theme.border_focus);
        });
    }

    /// Reset theme state to terminal (for testing).
    pub fn reset_theme_state() {
        set_theme_from(terminal());
    }
    ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod reactive;
    pub use reactive::*;
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `set_theme("dracula")` changes the active theme.
    `active_theme().name` returns "dracula" after set.
  </verify>
  <done>
    ACTIVE_THEME stores ReactiveTheme with per-field signals.
    set_theme() copies preset values to signals.
    reactive_theme() returns ReactiveTheme for deriveds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create t accessor with fine-grained deriveds</name>
  <files>src/theme/accessor.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/accessor.rs` with the t.* accessor pattern:

    ```rust
    //! Theme accessor for reactive color access.
    //!
    //! The t.* pattern provides ergonomic access to theme colors as Derived<Rgba>.
    //! Each derived tracks only its specific color signal, enabling fine-grained
    //! reactivity.

    use std::cell::RefCell;
    use spark_signals::{derived, Derived};
    use crate::types::Rgba;
    use super::reactive::reactive_theme;

    /// Accessor for reactive theme colors.
    ///
    /// Each field is a Derived<Rgba> that:
    /// - Reads from the specific color's Signal
    /// - Resolves ThemeColor to Rgba
    /// - Only re-runs when THAT color changes (fine-grained)
    ///
    /// # Example
    /// ```ignore
    /// use spark_tui::theme::t;
    ///
    /// // Get accessor
    /// let theme = t();
    ///
    /// // Use in props (these are Derived<Rgba>)
    /// let primary_color = theme.primary.get();
    ///
    /// // Or pass directly to component props
    /// BoxProps {
    ///     border_color: Some(theme.primary.into()),
    ///     ..Default::default()
    /// };
    /// ```
    #[derive(Clone)]
    pub struct ThemeAccessor {
        // Main palette
        pub primary: Derived<Rgba>,
        pub secondary: Derived<Rgba>,
        pub tertiary: Derived<Rgba>,
        pub accent: Derived<Rgba>,

        // Semantic
        pub success: Derived<Rgba>,
        pub warning: Derived<Rgba>,
        pub error: Derived<Rgba>,
        pub info: Derived<Rgba>,

        // Text
        pub text: Derived<Rgba>,
        pub text_muted: Derived<Rgba>,
        pub text_dim: Derived<Rgba>,
        pub text_disabled: Derived<Rgba>,
        pub text_bright: Derived<Rgba>,

        // Backgrounds (using bg prefix for brevity like TypeScript)
        pub bg: Derived<Rgba>,
        pub bg_muted: Derived<Rgba>,
        pub surface: Derived<Rgba>,
        pub overlay: Derived<Rgba>,

        // Borders
        pub border: Derived<Rgba>,
        pub border_focus: Derived<Rgba>,
    }

    impl ThemeAccessor {
        /// Create a new accessor with deriveds for each color.
        pub fn new() -> Self {
            let rt = reactive_theme();

            // Each derived reads from ONE signal - fine-grained tracking!
            Self {
                primary: derived({
                    let s = rt.primary.clone();
                    move || s.get().resolve()
                }),
                secondary: derived({
                    let s = rt.secondary.clone();
                    move || s.get().resolve()
                }),
                tertiary: derived({
                    let s = rt.tertiary.clone();
                    move || s.get().resolve()
                }),
                accent: derived({
                    let s = rt.accent.clone();
                    move || s.get().resolve()
                }),
                success: derived({
                    let s = rt.success.clone();
                    move || s.get().resolve()
                }),
                warning: derived({
                    let s = rt.warning.clone();
                    move || s.get().resolve()
                }),
                error: derived({
                    let s = rt.error.clone();
                    move || s.get().resolve()
                }),
                info: derived({
                    let s = rt.info.clone();
                    move || s.get().resolve()
                }),
                text: derived({
                    let s = rt.text.clone();
                    move || s.get().resolve()
                }),
                text_muted: derived({
                    let s = rt.text_muted.clone();
                    move || s.get().resolve()
                }),
                text_dim: derived({
                    let s = rt.text_dim.clone();
                    move || s.get().resolve()
                }),
                text_disabled: derived({
                    let s = rt.text_disabled.clone();
                    move || s.get().resolve()
                }),
                text_bright: derived({
                    let s = rt.text_bright.clone();
                    move || s.get().resolve()
                }),
                bg: derived({
                    let s = rt.background.clone();
                    move || s.get().resolve()
                }),
                bg_muted: derived({
                    let s = rt.background_muted.clone();
                    move || s.get().resolve()
                }),
                surface: derived({
                    let s = rt.surface.clone();
                    move || s.get().resolve()
                }),
                overlay: derived({
                    let s = rt.overlay.clone();
                    move || s.get().resolve()
                }),
                border: derived({
                    let s = rt.border.clone();
                    move || s.get().resolve()
                }),
                border_focus: derived({
                    let s = rt.border_focus.clone();
                    move || s.get().resolve()
                }),
            }
        }
    }

    impl Default for ThemeAccessor {
        fn default() -> Self {
            Self::new()
        }
    }

    thread_local! {
        /// Cached accessor - created once per thread, reused.
        static ACCESSOR: RefCell<Option<ThemeAccessor>> = const { RefCell::new(None) };
    }

    /// Get the theme accessor.
    ///
    /// Returns a ThemeAccessor with Derived<Rgba> for each color.
    /// The accessor is cached per thread for efficiency.
    ///
    /// # Example
    /// ```ignore
    /// use spark_tui::theme::{t, set_theme};
    ///
    /// let theme = t();
    /// let primary = theme.primary.get(); // Rgba
    ///
    /// set_theme("dracula");
    /// let new_primary = theme.primary.get(); // Updated!
    /// ```
    pub fn t() -> ThemeAccessor {
        ACCESSOR.with(|a| {
            let mut opt = a.borrow_mut();
            if opt.is_none() {
                *opt = Some(ThemeAccessor::new());
            }
            opt.clone().unwrap()
        })
    }

    /// Reset accessor cache (for testing).
    pub fn reset_accessor() {
        ACCESSOR.with(|a| *a.borrow_mut() = None);
    }
    ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod accessor;
    pub use accessor::{t, ThemeAccessor, reset_accessor};
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `t().primary.get()` returns the primary color as Rgba.
    Changing theme with `set_theme("nord")` updates `t().primary.get()`.
  </verify>
  <done>
    ThemeAccessor with fine-grained Derived<Rgba> fields.
    Each derived tracks only ONE signal (not entire theme).
    t() returns cached accessor.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add tests verifying fine-grained reactivity</name>
  <files>src/theme/reactive.rs, src/theme/accessor.rs</files>
  <action>
    Add tests proving fine-grained reactivity works:

    1. **Tests in reactive.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;
           use spark_signals::effect;
           use std::rc::Rc;
           use std::cell::Cell;

           #[test]
           fn test_default_theme_is_terminal() {
               reset_theme_state();
               assert_eq!(active_theme().name, "terminal");
           }

           #[test]
           fn test_set_theme_by_name() {
               reset_theme_state();
               set_theme("dracula");
               assert_eq!(active_theme().name, "dracula");
           }

           #[test]
           fn test_set_custom_theme() {
               reset_theme_state();
               let custom = Theme {
                   name: "custom".into(),
                   primary: ThemeColor::Rgb(Rgba::RED),
                   ..terminal()
               };
               set_custom_theme(custom);
               assert_eq!(active_theme().name, "custom");
           }

           #[test]
           fn test_reactive_theme_signals_independent() {
               reset_theme_state();
               let rt = reactive_theme();

               // Track how many times primary effect runs
               let primary_count = Rc::new(Cell::new(0));
               let count = primary_count.clone();
               let primary = rt.primary.clone();
               let _e1 = effect(move || {
                   let _ = primary.get();
                   count.set(count.get() + 1);
               });

               // Track how many times secondary effect runs
               let secondary_count = Rc::new(Cell::new(0));
               let count2 = secondary_count.clone();
               let secondary = rt.secondary.clone();
               let _e2 = effect(move || {
                   let _ = secondary.get();
                   count2.set(count2.get() + 1);
               });

               // Initial runs
               assert_eq!(primary_count.get(), 1);
               assert_eq!(secondary_count.get(), 1);

               // Change only primary
               rt.primary.set(ThemeColor::Rgb(Rgba::RED));

               // Only primary effect should re-run!
               assert_eq!(primary_count.get(), 2);
               assert_eq!(secondary_count.get(), 1); // Still 1!
           }
       }
       ```

    2. **Tests in accessor.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;
           use crate::theme::{reset_theme_state, set_theme, reactive_theme, ThemeColor};
           use crate::types::Rgba;
           use spark_signals::effect;
           use std::rc::Rc;
           use std::cell::Cell;

           #[test]
           fn test_t_accessor_returns_colors() {
               reset_theme_state();
               reset_accessor();
               let accessor = t();
               // Terminal theme uses ANSI 12 for primary
               let primary = accessor.primary.get();
               assert!(primary.is_ansi());
           }

           #[test]
           fn test_t_accessor_is_reactive() {
               reset_theme_state();
               reset_accessor();
               let accessor = t();

               let initial = accessor.primary.get();
               set_theme("dracula");
               let after = accessor.primary.get();

               assert_ne!(initial, after);
           }

           #[test]
           fn test_t_accessor_fine_grained() {
               reset_theme_state();
               reset_accessor();
               let accessor = t();

               // Track primary
               let primary_count = Rc::new(Cell::new(0));
               let count = primary_count.clone();
               let primary = accessor.primary.clone();
               let _e1 = effect(move || {
                   let _ = primary.get();
                   count.set(count.get() + 1);
               });

               // Track secondary
               let secondary_count = Rc::new(Cell::new(0));
               let count2 = secondary_count.clone();
               let secondary = accessor.secondary.clone();
               let _e2 = effect(move || {
                   let _ = secondary.get();
                   count2.set(count2.get() + 1);
               });

               assert_eq!(primary_count.get(), 1);
               assert_eq!(secondary_count.get(), 1);

               // Modify only primary via ReactiveTheme
               let rt = reactive_theme();
               rt.primary.set(ThemeColor::Rgb(Rgba::BLUE));

               // Only primary effect re-ran!
               assert_eq!(primary_count.get(), 2);
               assert_eq!(secondary_count.get(), 1);
           }

           #[test]
           fn test_set_theme_updates_all_colors() {
               reset_theme_state();
               reset_accessor();

               let accessor = t();
               let initial_primary = accessor.primary.get();
               let initial_secondary = accessor.secondary.get();

               set_theme("nord");

               let after_primary = accessor.primary.get();
               let after_secondary = accessor.secondary.get();

               // Both should change (nord has different colors)
               assert_ne!(initial_primary, after_primary);
               assert_ne!(initial_secondary, after_secondary);
           }
       }
       ```
  </action>
  <verify>
    `cargo test -p spark-tui theme -- --test-threads=1` passes all tests.
    Fine-grained test proves changing primary doesn't trigger secondary.
  </verify>
  <done>
    Tests verify default theme is terminal.
    Tests verify set_theme changes active theme.
    Tests verify fine-grained reactivity (key test!).
    Tests verify t.* accessors update correctly.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify fine-grained: changing primary signal doesn't trigger secondary effects
4. Verify: set_theme("dracula") updates all t.* colors
5. Verify: t().primary.get() returns correct resolved Rgba
</verification>

<success_criteria>
- Theme has #[derive(Reactive)] generating ReactiveTheme
- ACTIVE_THEME stores ReactiveTheme with per-field signals
- Changing one color only notifies that color's dependents (FINE-GRAINED!)
- set_theme() copies preset values to ReactiveTheme signals
- t() returns ThemeAccessor with Derived<Rgba> fields
- Each t.* derived tracks only ONE color signal
- Tests prove fine-grained reactivity works
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-theme-system/02-02-SUMMARY.md`
</output>
