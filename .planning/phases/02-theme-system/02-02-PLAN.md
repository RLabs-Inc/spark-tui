---
phase: 02-theme-system
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/theme/reactive.rs
  - src/theme/accessor.rs
  - src/theme/mod.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Active theme is stored in reactive signal"
    - "Changing theme updates all colors reactively"
    - "t.primary returns reactive Derived<Rgba>"
    - "t.* accessors track theme signal as dependency"
  artifacts:
    - path: "src/theme/reactive.rs"
      provides: "Reactive theme state and setTheme"
      exports: ["active_theme", "set_theme", "resolved_theme"]
      min_lines: 80
    - path: "src/theme/accessor.rs"
      provides: "t accessor struct with deriveds"
      exports: ["t", "ThemeAccessor"]
      min_lines: 100
  key_links:
    - from: "src/theme/accessor.rs"
      to: "src/theme/reactive.rs"
      via: "active_theme dependency"
      pattern: "active_theme\\(\\)"
    - from: "src/theme/reactive.rs"
      to: "spark_signals"
      via: "Signal import"
      pattern: "use spark_signals"
---

<objective>
Create the reactive theme system with signals and the t.* accessor pattern.

Purpose: Enable fully reactive theming where changing the active theme automatically propagates to all components using t.* accessors. This is the core reactivity that makes the theme system work.

Output: Reactive theme state with set_theme(), and t accessor struct where t.primary, t.bg, etc. return Derived<Rgba> that update when theme changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-theme-system/02-CONTEXT.md
@.planning/phases/02-theme-system/02-01-SUMMARY.md

# Reference implementation
# TypeScript: /Users/rusty/Documents/Projects/TUI/tui/src/state/theme.ts (lines 740-770 for t accessor)

# Rust modules
@src/theme/mod.rs
@src/theme/presets.rs
@src/state/keyboard.rs (for thread_local! pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reactive theme state</name>
  <files>src/theme/reactive.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/reactive.rs` with reactive theme state:

    1. **Thread-local signals** (like keyboard.rs pattern):
       ```rust
       use spark_signals::{signal, derived, Signal, Derived};
       use std::cell::RefCell;

       thread_local! {
           /// The active theme - changing this triggers all dependents
           static ACTIVE_THEME: RefCell<Signal<Theme>> = RefCell::new(signal(terminal()));

           /// Cached resolved colors - derived from active theme
           static RESOLVED: RefCell<Option<ResolvedTheme>> = RefCell::new(None);
       }

       /// All theme colors resolved to Rgba.
       #[derive(Debug, Clone)]
       pub struct ResolvedTheme {
           pub primary: Rgba,
           pub secondary: Rgba,
           pub tertiary: Rgba,
           pub accent: Rgba,
           pub success: Rgba,
           pub warning: Rgba,
           pub error: Rgba,
           pub info: Rgba,
           pub text: Rgba,
           pub text_muted: Rgba,
           pub text_dim: Rgba,
           pub text_disabled: Rgba,
           pub text_bright: Rgba,
           pub background: Rgba,
           pub background_muted: Rgba,
           pub surface: Rgba,
           pub overlay: Rgba,
           pub border: Rgba,
           pub border_focus: Rgba,
       }

       impl ResolvedTheme {
           pub fn from_theme(theme: &Theme) -> Self {
               Self {
                   primary: theme.primary.resolve(),
                   secondary: theme.secondary.resolve(),
                   // ... resolve all colors
               }
           }
       }
       ```

    2. **Public API**:
       ```rust
       /// Get the current active theme.
       pub fn active_theme() -> Theme {
           ACTIVE_THEME.with(|t| t.borrow().get())
       }

       /// Set the active theme by preset name.
       pub fn set_theme(name: &str) {
           if let Some(preset) = get_preset(name) {
               ACTIVE_THEME.with(|t| t.borrow().set(preset.clone()));
               // Invalidate resolved cache
               RESOLVED.with(|r| *r.borrow_mut() = None);
           }
       }

       /// Set a custom theme.
       pub fn set_custom_theme(theme: Theme) {
           ACTIVE_THEME.with(|t| t.borrow().set(theme));
           RESOLVED.with(|r| *r.borrow_mut() = None);
       }

       /// Get resolved colors (cached, recomputed when theme changes).
       pub fn resolved_theme() -> ResolvedTheme {
           RESOLVED.with(|r| {
               let mut cache = r.borrow_mut();
               if cache.is_none() {
                   let theme = active_theme();
                   *cache = Some(ResolvedTheme::from_theme(&theme));
               }
               cache.clone().unwrap()
           })
       }

       /// Get the active theme signal (for creating deriveds).
       pub fn theme_signal() -> Signal<Theme> {
           ACTIVE_THEME.with(|t| t.borrow().clone())
       }

       /// Reset theme state (for testing).
       pub fn reset_theme_state() {
           ACTIVE_THEME.with(|t| t.borrow().set(terminal()));
           RESOLVED.with(|r| *r.borrow_mut() = None);
       }
       ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod reactive;
    pub use reactive::*;
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `set_theme("dracula")` changes the active theme.
    `active_theme().name` returns "dracula" after set.
  </verify>
  <done>
    ACTIVE_THEME signal stores current theme.
    set_theme() changes active theme.
    resolved_theme() returns all colors as Rgba.
    theme_signal() exposes signal for deriveds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create t accessor with reactive deriveds</name>
  <files>src/theme/accessor.rs, src/theme/mod.rs</files>
  <action>
    Create `src/theme/accessor.rs` with the t.* accessor pattern:

    1. **ThemeAccessor struct**:
       ```rust
       use spark_signals::{derived, Derived};
       use crate::Rgba;
       use super::reactive::theme_signal;

       /// Accessor for reactive theme colors.
       /// Each field is a Derived<Rgba> that updates when the theme changes.
       ///
       /// # Usage
       /// ```
       /// use spark_tui::theme::t;
       ///
       /// box_primitive(BoxProps {
       ///     border_color: Some(t.primary.into()),
       ///     fg: Some(t.text.into()),
       ///     bg: Some(t.surface.into()),
       ///     ..Default::default()
       /// });
       /// ```
       pub struct ThemeAccessor {
           // Main palette
           pub primary: Derived<Rgba>,
           pub secondary: Derived<Rgba>,
           pub tertiary: Derived<Rgba>,
           pub accent: Derived<Rgba>,

           // Semantic
           pub success: Derived<Rgba>,
           pub warning: Derived<Rgba>,
           pub error: Derived<Rgba>,
           pub info: Derived<Rgba>,

           // Text
           pub text: Derived<Rgba>,
           pub text_muted: Derived<Rgba>,
           pub text_dim: Derived<Rgba>,
           pub text_disabled: Derived<Rgba>,
           pub text_bright: Derived<Rgba>,

           // Backgrounds
           pub bg: Derived<Rgba>,
           pub bg_muted: Derived<Rgba>,
           pub surface: Derived<Rgba>,
           pub overlay: Derived<Rgba>,

           // Borders
           pub border: Derived<Rgba>,
           pub border_focus: Derived<Rgba>,
       }

       impl ThemeAccessor {
           pub fn new() -> Self {
               let sig = theme_signal();

               Self {
                   primary: derived({
                       let s = sig.clone();
                       move || s.get().primary.resolve()
                   }),
                   secondary: derived({
                       let s = sig.clone();
                       move || s.get().secondary.resolve()
                   }),
                   // ... create derived for each field
               }
           }
       }

       impl Default for ThemeAccessor {
           fn default() -> Self {
               Self::new()
           }
       }
       ```

    2. **Global t accessor** (thread_local for lazy init):
       ```rust
       thread_local! {
           static ACCESSOR: RefCell<Option<ThemeAccessor>> = RefCell::new(None);
       }

       /// Get the theme accessor.
       /// All fields are reactive deriveds that update when theme changes.
       pub fn t() -> ThemeAccessor {
           ACCESSOR.with(|a| {
               let mut opt = a.borrow_mut();
               if opt.is_none() {
                   *opt = Some(ThemeAccessor::new());
               }
               opt.clone().unwrap()
           })
       }
       ```

       OR (simpler approach - create fresh each time, signals are cheap):
       ```rust
       /// Get theme accessor with reactive deriveds.
       pub fn t() -> ThemeAccessor {
           ThemeAccessor::new()
       }
       ```

    3. **PropValue integration** (if needed for component props):
       ```rust
       // In primitives/types.rs, ensure PropValue can accept Derived<Rgba>
       impl From<Derived<Rgba>> for PropValue<Rgba> {
           fn from(d: Derived<Rgba>) -> Self {
               PropValue::Getter(Rc::new(move || d.get()))
           }
       }
       ```

    Update `src/theme/mod.rs`:
    ```rust
    pub mod accessor;
    pub use accessor::{t, ThemeAccessor};
    ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `t().primary.get()` returns the primary color as Rgba.
    Changing theme with `set_theme("nord")` updates `t().primary.get()`.
  </verify>
  <done>
    ThemeAccessor struct with Derived<Rgba> fields.
    t() function returns accessor.
    All color fields track theme_signal() as dependency.
    Changing theme updates all t.* colors reactively.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and verify reactivity</name>
  <files>src/theme/reactive.rs, src/theme/accessor.rs</files>
  <action>
    Add comprehensive tests to verify the reactive behavior:

    1. **Tests in reactive.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;

           #[test]
           fn test_default_theme_is_terminal() {
               reset_theme_state();
               assert_eq!(active_theme().name, "terminal");
           }

           #[test]
           fn test_set_theme_by_name() {
               reset_theme_state();
               set_theme("dracula");
               assert_eq!(active_theme().name, "dracula");
           }

           #[test]
           fn test_set_custom_theme() {
               reset_theme_state();
               let custom = Theme {
                   name: "custom".into(),
                   primary: ThemeColor::Rgb(Rgba::RED),
                   ..terminal()
               };
               set_custom_theme(custom);
               assert_eq!(active_theme().name, "custom");
           }

           #[test]
           fn test_resolved_theme_caching() {
               reset_theme_state();
               let r1 = resolved_theme();
               let r2 = resolved_theme();
               // Should be cached (same values)
               assert_eq!(r1.primary, r2.primary);
           }

           #[test]
           fn test_theme_change_invalidates_cache() {
               reset_theme_state();
               let r1 = resolved_theme();
               set_theme("dracula");
               let r2 = resolved_theme();
               assert_ne!(r1.primary, r2.primary);
           }
       }
       ```

    2. **Tests in accessor.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;
           use spark_signals::effect;
           use std::rc::Rc;
           use std::cell::Cell;

           #[test]
           fn test_t_accessor_returns_colors() {
               reset_theme_state();
               let accessor = t();
               // Terminal theme uses ANSI 12 for primary
               let primary = accessor.primary.get();
               assert!(primary.is_ansi());
           }

           #[test]
           fn test_t_accessor_is_reactive() {
               reset_theme_state();
               let accessor = t();

               // Get initial value
               let initial = accessor.primary.get();

               // Change theme
               set_theme("dracula");

               // Accessor should reflect new theme
               let after = accessor.primary.get();
               assert_ne!(initial, after);
           }

           #[test]
           fn test_t_accessor_triggers_effects() {
               reset_theme_state();
               let call_count = Rc::new(Cell::new(0));
               let count = call_count.clone();

               let accessor = t();
               let _stop = effect({
                   let primary = accessor.primary.clone();
                   move || {
                       let _ = primary.get();
                       count.set(count.get() + 1);
                   }
               });

               // Initial run
               assert_eq!(call_count.get(), 1);

               // Change theme should trigger effect
               set_theme("nord");
               assert_eq!(call_count.get(), 2);
           }
       }
       ```

    3. **Integration test** (optional, in tests/ dir):
       ```rust
       // Verify t.* works with component props
       #[test]
       fn test_theme_with_box_props() {
           reset_theme_state();
           let accessor = t();

           // This should compile - t.* colors can be used in props
           let props = BoxProps {
               fg: Some(accessor.text.get().into()),
               bg: Some(accessor.bg.get().into()),
               ..Default::default()
           };
       }
       ```
  </action>
  <verify>
    `cargo test -p spark-tui theme -- --test-threads=1` passes all tests.
    Effect triggers when theme changes verify reactivity.
    All 13 presets can be set and accessed via t().
  </verify>
  <done>
    Tests verify default theme is terminal.
    Tests verify set_theme changes active theme.
    Tests verify t.* accessors are reactive.
    Tests verify effects trigger on theme change.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui theme -- --test-threads=1` - All tests pass
3. Verify reactivity: set_theme("dracula"), then t().primary.get() returns Dracula purple
4. Verify: Creating effect with t().primary triggers on theme change
</verification>

<success_criteria>
- ACTIVE_THEME signal stores current theme state
- set_theme() changes active theme by name
- set_custom_theme() accepts custom Theme
- t() returns ThemeAccessor with Derived<Rgba> fields
- t().primary, t().bg, t().text etc. all work
- Changing theme updates all t.* accessors reactively
- Effects using t.* colors re-run when theme changes
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-theme-system/02-02-SUMMARY.md`
</output>
