---
phase: 04-scroll-system
plan: 05
type: execute
wave: 1
depends_on: ["04-04"]
files_modified:
  - src/pipeline/mod.rs
  - src/pipeline/layout_derived.rs
  - src/state/scroll.rs
  - src/primitives/box_primitive.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "get_layout() returns current computed layout from global derived"
    - "Scroll handlers use get_layout() directly (no imperative caching)"
    - "stick_to_bottom creates scoped effect in Box component"
    - "Mouse wheel focused fallback uses chaining"
  artifacts:
    - path: "src/pipeline/layout_derived.rs"
      provides: "Global layout accessor"
      contains: "get_layout"
    - path: "src/state/scroll.rs"
      provides: "Handlers using get_layout()"
      exports: ["handle_arrow_scroll", "handle_page_scroll", "handle_home_end"]
    - path: "src/primitives/box_primitive.rs"
      provides: "stick_to_bottom effect"
      contains: "effect.*stick_to_bottom"
  key_links:
    - from: "src/state/scroll.rs"
      to: "src/pipeline/layout_derived.rs"
      via: "get_layout() call"
      pattern: "layout_derived::get_layout"
    - from: "src/primitives/box_primitive.rs"
      to: "src/state/scroll.rs"
      via: "effect calling handle_stick_to_bottom"
      pattern: "scroll::handle_stick_to_bottom"
---

<objective>
Wire scroll system into render pipeline with reactive architecture.

Purpose: Fix two BLOCKER gaps from Phase 4 verification:
1. Keyboard scroll handlers can't access layout (set_current_layout never called)
2. stick_to_bottom auto-scroll never triggered (handle_stick_to_bottom orphaned)

Architectural solution (per user discussion):
- Replace imperative `set_current_layout()` cache with global `get_layout()` accessor
- Replace orphaned `handle_stick_to_bottom()` call with reactive effect in Box component
- Fix mouse wheel focused fallback to use chaining

Output: Fully integrated scroll system with reactive architecture.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-scroll-system/04-VERIFICATION.md

# Core files being modified
@src/pipeline/layout_derived.rs
@src/pipeline/mod.rs
@src/state/scroll.rs
@src/primitives/box_primitive.rs

# TypeScript reference pattern
# In TypeScript: layoutDerived.value is globally accessible
# In Rust: Need get_layout() that reads from global layout derived
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global layout accessor in layout_derived.rs</name>
  <files>src/pipeline/layout_derived.rs, src/pipeline/mod.rs</files>
  <action>
Make layout_derived globally accessible like TypeScript's `layoutDerived.value`:

1. In `src/pipeline/layout_derived.rs`, add thread-local storage for the global layout derived:

```rust
use std::cell::RefCell;
use spark_signals::Derived;

// Thread-local storage for the global layout derived
thread_local! {
    static LAYOUT_DERIVED: RefCell<Option<Derived<ComputedLayout, Box<dyn Fn() -> ComputedLayout>>>> = RefCell::new(None);
}

/// Initialize the global layout derived.
/// Called by mount() when setting up the render pipeline.
pub fn init_layout_derived() {
    let layout_d = create_layout_derived_boxed();
    LAYOUT_DERIVED.with(|ld| {
        *ld.borrow_mut() = Some(layout_d);
    });
}

/// Create layout derived with boxed closure (needed for type erasure in thread_local).
fn create_layout_derived_boxed() -> Derived<ComputedLayout, Box<dyn Fn() -> ComputedLayout>> {
    let tw_signal = terminal_width_signal();
    let th_signal = terminal_height_signal();
    let mode_signal = render_mode_signal();

    let compute: Box<dyn Fn() -> ComputedLayout> = Box::new(move || {
        let tw = tw_signal.get();
        let th = th_signal.get();
        let mode = mode_signal.get();
        let constrain_height = mode == RenderMode::Fullscreen;
        compute_layout(tw, th, constrain_height)
    });

    spark_signals::derived_boxed(compute)
}

/// Get the current computed layout.
///
/// This is the primary way scroll handlers access layout data.
/// Mirrors TypeScript's `layoutDerived.value` pattern.
///
/// # Panics
///
/// Panics if called before mount() initializes the layout derived.
pub fn get_layout() -> ComputedLayout {
    LAYOUT_DERIVED.with(|ld| {
        ld.borrow()
            .as_ref()
            .expect("get_layout() called before mount() initialized layout derived")
            .get()
    })
}

/// Clear the global layout derived (for unmount/testing).
pub fn clear_layout_derived() {
    LAYOUT_DERIVED.with(|ld| {
        *ld.borrow_mut() = None;
    });
}
```

Note: `derived_boxed` may not exist in spark-signals. If so, use `derived` with type annotation:
```rust
pub fn init_layout_derived() {
    // Keep the derived in a RefCell storing the actual derived value
    let tw_signal = terminal_width_signal();
    let th_signal = terminal_height_signal();
    let mode_signal = render_mode_signal();

    let layout_d = derived(move || {
        let tw = tw_signal.get();
        let th = th_signal.get();
        let mode = mode_signal.get();
        let constrain_height = mode == RenderMode::Fullscreen;
        compute_layout(tw, th, constrain_height)
    });

    // Store in thread-local
    LAYOUT_DERIVED.with(|ld| {
        *ld.borrow_mut() = Some(layout_d);
    });
}
```

For the thread_local, use `Option<Box<dyn Any>>` and downcast, OR use a simpler approach:

```rust
thread_local! {
    /// Cached layout - updated by mount()'s render effect before each frame.
    static CURRENT_LAYOUT: RefCell<Option<ComputedLayout>> = RefCell::new(None);
}

/// Update the cached layout. Called by render effect after layout computation.
pub fn set_layout(layout: ComputedLayout) {
    CURRENT_LAYOUT.with(|l| *l.borrow_mut() = Some(layout));
}

/// Get the current computed layout.
/// Returns a clone of the cached layout.
pub fn get_layout() -> ComputedLayout {
    CURRENT_LAYOUT.with(|l| {
        l.borrow().clone().expect("get_layout() called before layout computed")
    })
}

/// Clear the cached layout (for unmount/testing).
pub fn clear_layout() {
    CURRENT_LAYOUT.with(|l| *l.borrow_mut() = None);
}
```

Pick the simpler cache approach since it aligns with how we actually need to use it - the render effect already computes layout via `layout_derived.get()` and we just need to expose that value.

2. In `src/pipeline/mod.rs`, add re-export:
```rust
pub use layout_derived::{get_layout, set_layout, clear_layout};
```
  </action>
  <verify>
`cargo build -p spark-tui` compiles with no errors.
  </verify>
  <done>
Global layout accessor (`get_layout()`, `set_layout()`, `clear_layout()`) implemented in layout_derived.rs and re-exported from pipeline mod.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update scroll.rs to use get_layout() and remove old pattern</name>
  <files>src/state/scroll.rs</files>
  <action>
Refactor scroll.rs to use the new global layout accessor:

1. Remove the old imperative pattern (lines 33-67):
   - Delete `CURRENT_LAYOUT` thread_local
   - Delete `set_current_layout()`
   - Delete `with_current_layout()`
   - Delete `clear_current_layout()`

2. Update keyboard handlers to use `get_layout()` directly:

```rust
use crate::pipeline::get_layout;

/// Handle arrow key scroll for focused scrollable.
/// Returns true if scroll occurred.
pub fn handle_arrow_scroll(direction: ScrollDirection) -> bool {
    let layout = get_layout();
    let scrollable = get_focused_scrollable(&layout);
    if scrollable < 0 {
        return false;
    }

    let idx = scrollable as usize;
    match direction {
        ScrollDirection::Up => scroll_by(&layout, idx, 0, -(LINE_SCROLL as i32)),
        ScrollDirection::Down => scroll_by(&layout, idx, 0, LINE_SCROLL as i32),
        ScrollDirection::Left => scroll_by(&layout, idx, -(LINE_SCROLL as i32), 0),
        ScrollDirection::Right => scroll_by(&layout, idx, LINE_SCROLL as i32, 0),
    }
}

/// Handle PageUp/PageDown scroll.
pub fn handle_page_scroll(direction: ScrollDirection) -> bool {
    let layout = get_layout();
    let scrollable = get_focused_scrollable(&layout);
    if scrollable < 0 {
        return false;
    }

    let idx = scrollable as usize;
    let viewport_height = layout.height.get(idx).copied().unwrap_or(10) as f32;
    let page_amount = (viewport_height * PAGE_SCROLL_FACTOR).max(1.0) as i32;

    match direction {
        ScrollDirection::Up => scroll_by(&layout, idx, 0, -page_amount),
        ScrollDirection::Down => scroll_by(&layout, idx, 0, page_amount),
        _ => false,
    }
}

/// Handle Ctrl+Home/End for scroll to top/bottom.
pub fn handle_home_end(to_top: bool) -> bool {
    let layout = get_layout();
    let scrollable = get_focused_scrollable(&layout);
    if scrollable < 0 {
        return false;
    }

    let idx = scrollable as usize;
    if to_top {
        scroll_to_top(&layout, idx);
    } else {
        scroll_to_bottom(&layout, idx);
    }
    true
}
```

3. Update `handle_wheel_scroll` to use `get_layout()` AND fix the focused fallback to use chaining:

```rust
/// Handle mouse wheel scroll at coordinates.
/// First tries element under cursor, then falls back to focused scrollable.
/// Uses chaining for both (unlike keyboard scroll).
pub fn handle_wheel_scroll(x: u16, y: u16, direction: ScrollDirection) -> bool {
    use crate::state::mouse::hit_test;

    let layout = get_layout();

    // Try element under cursor via hit test
    let component_at = hit_test(x, y);

    // If component at cursor is scrollable, scroll it (with chaining)
    if let Some(idx) = component_at {
        if is_scrollable(&layout, idx) {
            let delta = match direction {
                ScrollDirection::Up => (0, -(WHEEL_SCROLL as i32)),
                ScrollDirection::Down => (0, WHEEL_SCROLL as i32),
                ScrollDirection::Left => (-(WHEEL_SCROLL as i32), 0),
                ScrollDirection::Right => (WHEEL_SCROLL as i32, 0),
            };
            return scroll_by_with_chaining(&layout, idx, delta.0, delta.1);
        }
    }

    // Fallback to focused scrollable (NOW ALSO WITH CHAINING - this is the bug fix)
    let scrollable = get_focused_scrollable(&layout);
    if scrollable >= 0 {
        let idx = scrollable as usize;
        let delta = match direction {
            ScrollDirection::Up => (0, -(WHEEL_SCROLL as i32)),
            ScrollDirection::Down => (0, WHEEL_SCROLL as i32),
            ScrollDirection::Left => (-(WHEEL_SCROLL as i32), 0),
            ScrollDirection::Right => (WHEEL_SCROLL as i32, 0),
        };
        // FIX: Use scroll_by_with_chaining instead of scroll_by
        scroll_by_with_chaining(&layout, idx, delta.0, delta.1)
    } else {
        false
    }
}
```

4. Update tests to not use the old pattern. Replace any usage of:
   - `set_current_layout(layout)` - delete
   - `with_current_layout(|l| ...)` - use `get_layout()` directly
   - `clear_current_layout()` - use `clear_layout()` from pipeline

For tests, set up layout via `set_layout()`:
```rust
use crate::pipeline::{set_layout, clear_layout};

fn setup_with_layout(layout: ComputedLayout) {
    reset_registry();
    reset_focus_state();
    interaction::reset();
    set_layout(layout);
}

// In teardown or after tests:
clear_layout();
```
  </action>
  <verify>
`cargo test -p spark-tui scroll` passes.
`cargo test -p spark-tui` passes (no regressions).
  </verify>
  <done>
scroll.rs refactored to use `get_layout()`. Old imperative pattern removed. Mouse wheel focused fallback now uses chaining.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add stick_to_bottom effect in Box component</name>
  <files>src/primitives/box_primitive.rs</files>
  <action>
Add a scoped effect to Box when `stick_to_bottom: true` that handles auto-scroll reactively:

1. Import necessary items at top of file:
```rust
use spark_signals::effect;
use crate::pipeline::get_layout;
use crate::state::scroll;
```

2. After the existing stick_to_bottom prop handling (around line 240), add the reactive effect:

```rust
// Stick to bottom (auto-scroll on content growth)
let mut stick_effect_cleanup: Option<Box<dyn FnOnce()>> = None;

if props.stick_to_bottom {
    interaction::set_stick_to_bottom(index, true);

    // Create reactive effect that watches layout and auto-scrolls
    // This effect will re-run whenever layout changes (content grows)
    let effect_index = index;
    let stop_effect = effect(move || {
        // Reading get_layout() inside effect creates dependency on layout_derived
        // When layout changes, this effect re-runs
        let layout = get_layout();

        // Call the existing handler which checks:
        // - Is stick_to_bottom enabled?
        // - Is component scrollable?
        // - Did content grow (max_scroll_y > prev_max_scroll_y)?
        // - Were we at bottom before growth?
        scroll::handle_stick_to_bottom(&layout, effect_index);
    });

    stick_effect_cleanup = Some(Box::new(stop_effect));
}
```

3. In the cleanup closure at the end (around line 437), add cleanup for the effect:

```rust
// 11. RETURN CLEANUP
Box::new(move || {
    // Clean up mouse handlers
    if let Some(cleanup) = mouse_cleanup {
        cleanup();
    }
    // Clean up keyboard handlers
    if let Some(cleanup) = key_cleanup {
        cleanup();
    }
    // Clean up focus callbacks
    if let Some(cleanup) = focus_cleanup {
        cleanup();
    }
    // Clean up stick_to_bottom effect
    if let Some(cleanup) = stick_effect_cleanup {
        cleanup();
    }
    // Clean up component state in mouse/keyboard modules
    mouse::cleanup_index(index);
    keyboard::cleanup_index(index);
    // Release index
    release_index(index);
})
```

Important: The effect needs to be scoped to the component's lifetime. It:
- Creates a reactive dependency on layout (via `get_layout()`)
- When layout changes, checks if auto-scroll should happen
- Cleans up when Box is destroyed

Note: If `get_layout()` panics because layout isn't initialized yet (during component creation before mount), wrap in a check:

```rust
let stop_effect = effect(move || {
    // Guard: Layout may not be initialized during initial component creation
    use crate::pipeline::layout_derived::CURRENT_LAYOUT;
    let has_layout = CURRENT_LAYOUT.with(|l| l.borrow().is_some());
    if !has_layout {
        return;
    }

    let layout = get_layout();
    scroll::handle_stick_to_bottom(&layout, effect_index);
});
```

Or better - add a `try_get_layout()` that returns `Option<ComputedLayout>`:

```rust
// In layout_derived.rs
pub fn try_get_layout() -> Option<ComputedLayout> {
    CURRENT_LAYOUT.with(|l| l.borrow().clone())
}
```

Then in the effect:
```rust
let stop_effect = effect(move || {
    if let Some(layout) = crate::pipeline::try_get_layout() {
        scroll::handle_stick_to_bottom(&layout, effect_index);
    }
});
```
  </action>
  <verify>
`cargo build -p spark-tui` compiles.
`cargo test -p spark-tui stick_to_bottom` passes.
  </verify>
  <done>
stick_to_bottom reactive effect added to Box component. Effect creates dependency on layout_derived and auto-scrolls when content grows.
  </done>
</task>

</tasks>

<verification>
- [ ] `cargo build -p spark-tui` compiles
- [ ] `cargo test -p spark-tui` passes (all ~370 tests)
- [ ] Old pattern removed: `set_current_layout`, `with_current_layout`, `CURRENT_LAYOUT` thread_local in scroll.rs
- [ ] New pattern: `get_layout()` from `pipeline::layout_derived`
- [ ] Keyboard scroll handlers use `get_layout()` directly
- [ ] Mouse wheel focused fallback uses `scroll_by_with_chaining`
- [ ] stick_to_bottom Box creates reactive effect
- [ ] Effect cleans up when Box is destroyed
</verification>

<success_criteria>
- `get_layout()` accessible from `crate::pipeline`
- No more `set_current_layout`, `with_current_layout`, `clear_current_layout` in scroll.rs
- `handle_arrow_scroll(direction)`, `handle_page_scroll(direction)`, `handle_home_end(to_top)` - no layout parameter
- `handle_wheel_scroll(x, y, direction)` - no layout parameter, uses chaining for focused fallback
- Box with `stick_to_bottom: true` creates effect that watches layout
- All existing tests pass
- Integration: keyboard scroll works in real app (layout accessible)
- Integration: stick_to_bottom auto-scrolls when content grows
</success_criteria>

<output>
After completion, create `.planning/phases/04-scroll-system/04-05-SUMMARY.md`
</output>
