---
phase: 06-control-flow
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/primitives/control_flow.rs
autonomous: true

must_haves:
  truths:
    - "when() renders pending UI while in Pending state"
    - "when() renders then UI when state becomes Resolved"
    - "when() renders catch UI when state becomes Rejected"
    - "when() logs unhandled rejections without crash"
    - "when() cleans up previous state UI on state change"
    - "when() works with reactive state getter"
  artifacts:
    - path: "src/primitives/control_flow.rs"
      provides: "when() async rendering function and AsyncState enum"
      exports: ["when", "AsyncState", "WhenOptions"]
      min_lines: 250
  key_links:
    - from: "src/primitives/control_flow.rs:when"
      to: "AsyncState enum"
      via: "State machine for pending/resolved/rejected"
      pattern: "AsyncState::(Pending|Resolved|Rejected)"
---

<objective>
Implement when() async state handling primitive with polling-based approach.

Purpose: Enable async UI patterns where loading/success/error states are rendered based on external async state. Uses polling-based AsyncState<T, E> enum rather than direct Future integration - users manage their async state, when() just renders based on it.

Output: Working when() function with AsyncState enum, WhenOptions struct, and proper state machine rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-control-flow/06-CONTEXT.md
@.planning/phases/06-control-flow/06-RESEARCH.md
@.planning/phases/06-control-flow/06-01-SUMMARY.md
@.planning/phases/06-control-flow/06-02-SUMMARY.md

# TypeScript reference (for pattern, adapted to polling)
@/Users/rusty/Documents/Projects/TUI/tui/src/primitives/when.ts

# Rust patterns to follow
@src/primitives/types.rs (Cleanup type)
@src/engine/registry.rs (parent context stack)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AsyncState enum and WhenOptions struct</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
Add AsyncState and WhenOptions types to `src/primitives/control_flow.rs`:

1. **AsyncState enum:**
   ```rust
   /// Async state for when() rendering.
   ///
   /// Users manage their own async operations and update a Signal<AsyncState<T, E>>
   /// to trigger UI changes. This polling-based approach avoids runtime dependencies.
   ///
   /// # Example
   /// ```ignore
   /// let state: Signal<AsyncState<Data, String>> = signal(AsyncState::Pending);
   ///
   /// // In your async code (tokio, async-std, etc.):
   /// // On success: state.set(AsyncState::Resolved(data));
   /// // On error: state.set(AsyncState::Rejected("error".to_string()));
   /// ```
   #[derive(Clone, Debug, PartialEq)]
   pub enum AsyncState<T, E> {
       /// Loading state - async operation in progress.
       Pending,
       /// Success state - operation completed with value.
       Resolved(T),
       /// Error state - operation failed with error.
       Rejected(E),
   }
   ```

2. **WhenOptions struct (simplified - no new() constructor):**
   ```rust
   /// Options for when() async rendering.
   ///
   /// Construct directly with struct literal syntax:
   /// ```ignore
   /// WhenOptions {
   ///     pending: Some(|| text(TextProps { content: "Loading...".into(), ..default() })),
   ///     then_fn: |data| text(TextProps { content: data.to_string().into(), ..default() }),
   ///     catch_fn: Some(|err| text(TextProps { content: format!("Error: {}", err).into(), ..default() })),
   ///     _marker: PhantomData,
   /// }
   /// ```
   pub struct WhenOptions<T, E, PendingF, ThenF, CatchF>
   where
       T: Clone + 'static,
       E: Clone + std::fmt::Display + 'static,
   {
       /// Render function for Pending state (optional).
       /// If None, nothing is rendered during pending.
       pub pending: Option<PendingF>,
       /// Render function for Resolved state (required).
       pub then_fn: ThenF,
       /// Render function for Rejected state (optional).
       /// If None, errors are logged but nothing rendered.
       pub catch_fn: Option<CatchF>,
       /// PhantomData for T and E type inference.
       pub _marker: std::marker::PhantomData<(T, E)>,
   }
   ```

   **Note:** No `new()` constructor - users construct directly with struct literal. This avoids complex Default bounds on function types that don't make sense.

3. **Update exports in `src/primitives/mod.rs`:**
   - Ensure `pub use control_flow::{when, AsyncState, WhenOptions};` is present
  </action>
  <verify>
`cargo check -p spark-tui` compiles without errors.
  </verify>
  <done>
AsyncState enum and WhenOptions struct exist with correct signatures.
Types exported from primitives module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement when() function</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
Add the `when()` function to `src/primitives/control_flow.rs`:

1. **Function signature:**
   ```rust
   /// Render based on async state (polling-based).
   ///
   /// Unlike Promise-based when() in JavaScript, this version works with
   /// a reactive getter that returns AsyncState<T, E>. Users manage their
   /// own async operations and update the state signal accordingly.
   ///
   /// # Example
   /// ```ignore
   /// let fetch_state = signal(AsyncState::Pending);
   /// let fetch_state_clone = fetch_state.clone();
   ///
   /// // Start async operation (user's responsibility)
   /// spawn(async move {
   ///     match fetch_data().await {
   ///         Ok(data) => fetch_state_clone.set(AsyncState::Resolved(data)),
   ///         Err(e) => fetch_state_clone.set(AsyncState::Rejected(e.to_string())),
   ///     }
   /// });
   ///
   /// // Render based on state
   /// when(
   ///     move || fetch_state.get(),
   ///     WhenOptions {
   ///         pending: Some(|| text(TextProps { content: "Loading...".into(), ..default() })),
   ///         then_fn: |data| text(TextProps { content: data.to_string().into(), ..default() }),
   ///         catch_fn: Some(|err| text(TextProps { content: format!("Error: {}", err).into(), ..default() })),
   ///         _marker: PhantomData,
   ///     },
   /// )
   /// ```
   pub fn when<T, E, PendingF, ThenF, CatchF, PendingR, ThenR, CatchR>(
       state_getter: impl Fn() -> AsyncState<T, E> + 'static,
       options: WhenOptions<T, E, PendingF, ThenF, CatchF>,
   ) -> Cleanup
   where
       T: Clone + 'static,
       E: Clone + std::fmt::Display + 'static,
       PendingF: Fn() -> PendingR + 'static,
       ThenF: Fn(T) -> ThenR + 'static,
       CatchF: Fn(E) -> CatchR + 'static,
       PendingR: Into<Cleanup>,
       ThenR: Into<Cleanup>,
       CatchR: Into<Cleanup>,
   ```

2. **Implementation pattern:**
   - Capture parent index at creation time
   - Create `effect_scope()` for cleanup management
   - Create `Rc<RefCell<Option<Cleanup>>>` for current state cleanup
   - Inside `scope.run()`:
     - Create effect that:
       a. Reads state via `state_getter()` (establishes dependency)
       b. Cleanup previous render if exists
       c. Push parent context
       d. Match on state:
          - `AsyncState::Pending`: if `options.pending.is_some()`, call it
          - `AsyncState::Resolved(data)`: call `options.then_fn(data)`
          - `AsyncState::Rejected(err)`: if `options.catch_fn.is_some()`, call it; else log to stderr
       e. Pop parent context
       f. Store new cleanup
     - Register `on_scope_dispose()` to cleanup current render
   - Return `Box::new(move || scope.stop())`

3. **Unhandled rejection logging:**
   ```rust
   AsyncState::Rejected(err) => {
       if let Some(ref catch_fn) = options.catch_fn {
           new_cleanup = Some(catch_fn(err).into());
       } else {
           eprintln!("[when] Unhandled rejection: {}", err);
           // No render for unhandled error
       }
   }
   ```
  </action>
  <verify>
`cargo check -p spark-tui` compiles without errors.
  </verify>
  <done>
when() function exists with correct signature and state machine rendering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for when()</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
**Pre-verification:** Confirm registry API availability (same as plans 01, 02):
- `reset_registry`, `allocate_index`, `release_index`, `get_allocated_count`

Add tests to the existing `#[cfg(test)] mod tests` in control_flow.rs:

1. **test_when_renders_pending:**
   - Create `signal(AsyncState::Pending)` state
   - Call when with pending handler
   - Verify pending component created

2. **test_when_renders_resolved:**
   - Create `signal(AsyncState::Resolved("data".to_string()))` state
   - Call when with then_fn
   - Verify then component created with data

3. **test_when_renders_rejected:**
   - Create `signal(AsyncState::Rejected("error".to_string()))` state
   - Call when with catch_fn
   - Verify catch component created

4. **test_when_transitions_pending_to_resolved:**
   - Start with Pending state
   - Call when, verify pending UI
   - Set state to Resolved
   - Verify pending destroyed, then UI rendered

5. **test_when_transitions_pending_to_rejected:**
   - Start with Pending state
   - Call when, verify pending UI
   - Set state to Rejected
   - Verify pending destroyed, catch UI rendered

6. **test_when_no_pending_handler:**
   - Create when with `pending: None`
   - State is Pending
   - Verify no component created (no crash)

7. **test_when_no_catch_handler:**
   - Create when with `catch_fn: None`
   - State becomes Rejected
   - Verify no crash, error logged to stderr
   - Verify no component created for error state

8. **test_when_cleanup_destroys_current:**
   - Create when in Resolved state
   - Call returned cleanup
   - Verify component destroyed

9. **test_when_nested_parent_context:**
   - Create parent Box
   - Inside Box children, call when()
   - Verify when's components have correct parent

10. **test_when_multiple_state_changes:**
    - Pending -> Resolved -> Rejected -> Resolved
    - Verify each transition cleans up previous and renders new

**Helper struct for tests:**
```rust
// Use String for both T and E for simple testing
type TestState = AsyncState<String, String>;
```
  </action>
  <verify>
`cargo test -p spark-tui when` runs all when tests and they pass.
  </verify>
  <done>
10+ tests for when() covering all states and transitions.
All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p spark-tui` - no errors
2. `cargo test -p spark-tui when` - all when tests pass
3. `cargo test -p spark-tui` - no regressions (all existing tests pass)
4. `cargo doc -p spark-tui --no-deps` - docs generate for AsyncState, WhenOptions, when()
</verification>

<success_criteria>
- AsyncState<T, E> enum exported with Pending/Resolved/Rejected variants
- WhenOptions struct exported with pending/then_fn/catch_fn fields (direct construction, no new())
- when() function exported from spark_tui::primitives
- when() renders appropriate UI based on AsyncState
- when() transitions cleanly between states
- when() handles missing pending/catch handlers gracefully
- Unhandled rejections logged to stderr without crash
- 10+ tests covering all states and transitions
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-control-flow/06-03-SUMMARY.md`
</output>
