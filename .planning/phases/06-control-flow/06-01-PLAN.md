---
phase: 06-control-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/primitives/control_flow.rs
  - src/primitives/mod.rs
autonomous: true

must_haves:
  truths:
    - "show() renders then_fn when condition is true"
    - "show() renders else_fn when condition is false"
    - "show() destroys components when condition toggles"
    - "show() tracks reactive dependencies in condition getter"
    - "show() preserves parent context for nested components"
  artifacts:
    - path: "src/primitives/control_flow.rs"
      provides: "show() conditional rendering function"
      exports: ["show"]
      min_lines: 80
  key_links:
    - from: "src/primitives/control_flow.rs"
      to: "spark_signals::effect_scope"
      via: "EffectScope for cleanup management"
      pattern: "effect_scope\\(\\)"
    - from: "src/primitives/control_flow.rs"
      to: "registry::push_parent_context"
      via: "Parent context restoration"
      pattern: "push_parent_context"
---

<objective>
Implement show() conditional rendering primitive.

Purpose: Enable dynamic UI where components appear/disappear based on reactive conditions. This is the foundation pattern for all control flow - EffectScope-based cleanup with parent context restoration.

Output: Working show() function that tracks condition changes, destroys/creates components on toggle, and properly handles cleanup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-control-flow/06-CONTEXT.md
@.planning/phases/06-control-flow/06-RESEARCH.md

# TypeScript reference
@/Users/rusty/Documents/Projects/TUI/tui/src/primitives/show.ts

# Rust patterns to follow
@src/primitives/types.rs (Cleanup type)
@src/engine/registry.rs (parent context stack)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create control_flow module with show() function</name>
  <files>src/primitives/control_flow.rs, src/primitives/mod.rs</files>
  <action>
Create `src/primitives/control_flow.rs` with the `show()` function:

1. **Imports:**
   - `spark_signals::{effect, effect_scope, on_scope_dispose}`
   - `std::cell::{Cell, RefCell}`, `std::rc::Rc`
   - `crate::engine::registry::{get_current_parent_index, push_parent_context, pop_parent_context}`
   - `crate::primitives::Cleanup`

2. **Function signature:**
   ```rust
   pub fn show<ThenF, ElseF, ThenR, ElseR>(
       condition: impl Fn() -> bool + 'static,
       then_fn: ThenF,
       else_fn: Option<ElseF>,
   ) -> Cleanup
   where
       ThenF: Fn() -> ThenR + 'static,
       ElseF: Fn() -> ElseR + 'static,
       ThenR: Into<Cleanup>,
       ElseR: Into<Cleanup>,
   ```

3. **Implementation pattern (from TypeScript show.ts):**
   - Capture parent index at creation time with `get_current_parent_index()`
   - Create `effect_scope()` for cleanup management
   - Use `Rc<RefCell<Option<Cleanup>>>` for current cleanup storage
   - Use `Rc<Cell<Option<bool>>>` for `was_true` state tracking
   - Inside `scope.run()`:
     - Create effect that reads condition (establishes dependency)
     - On first run: render appropriate branch
     - On subsequent runs: skip if condition unchanged, else cleanup + re-render
     - Use `push_parent_context(parent)` / `pop_parent_context()` around render
   - Register `on_scope_dispose()` to cleanup on scope stop
   - Return `Box::new(move || scope.stop())` as Cleanup

4. **Key detail from TypeScript:** The effect reads condition to track dependency but skips the initial render (already done synchronously). Adapt for Rust: do the initial render inside the effect on first call.

5. **Handle None parent:** If `get_current_parent_index()` returns None, skip push/pop (root level).

6. **Update `src/primitives/mod.rs`:**
   - Add `mod control_flow;`
   - Add `pub use control_flow::show;`

7. **Add module documentation** explaining:
   - How show() destroys/recreates components on condition change
   - Why parent context capture is important
   - The EffectScope cleanup pattern
  </action>
  <verify>
`cargo check -p spark-tui` compiles without errors.
`cargo doc -p spark-tui --no-deps` generates docs for show().
  </verify>
  <done>
show() function exists with correct signature and implementation pattern.
Module exports show from primitives.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for show()</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
Add `#[cfg(test)] mod tests` to control_flow.rs with these test cases:

1. **test_show_renders_then_when_true:**
   - Create `signal(true)` condition
   - Call `show(move || cond.get(), || create_component(), None::<fn() -> Cleanup>)`
   - Verify component was created (check registry allocation count)

2. **test_show_renders_else_when_false:**
   - Create `signal(false)` condition
   - Call show with both then and else branches
   - Verify else component created, then component NOT created

3. **test_show_toggles_components:**
   - Create `signal(true)` condition
   - Call show, verify "then" component exists
   - Set condition to false
   - Verify "then" component destroyed, "else" component created
   - Set condition back to true
   - Verify "else" destroyed, "then" created

4. **test_show_cleanup_destroys_all:**
   - Create show with condition true
   - Verify component exists
   - Call the returned cleanup
   - Verify component destroyed

5. **test_show_no_change_no_recreate:**
   - Create show with true condition
   - Get component index
   - Set condition to true again (no change)
   - Verify same component (no recreation)

6. **test_show_nested_parent_context:**
   - Create parent Box
   - Inside Box children, call show()
   - Verify show's components have correct parent

7. **test_show_no_else:**
   - Create show with None else_fn
   - Condition true: component exists
   - Condition false: no component (not crash)

**Helper function for tests:**
```rust
fn create_test_component() -> Cleanup {
    let index = allocate_index(None);
    Box::new(move || release_index(index))
}
```

Import from registry for test setup: `reset_registry`, `allocate_index`, `release_index`, `get_allocated_count`.
  </action>
  <verify>
`cargo test -p spark-tui show` runs all show tests and they pass.
  </verify>
  <done>
7+ tests for show() covering happy path, toggles, cleanup, nested context.
All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p spark-tui` - no errors
2. `cargo test -p spark-tui show` - all show tests pass
3. `cargo test -p spark-tui` - no regressions (all existing tests pass)
4. `cargo doc -p spark-tui --no-deps` - docs generate
</verification>

<success_criteria>
- show() function exported from spark_tui::primitives
- show() creates components when condition true
- show() destroys components when condition becomes false
- show() supports optional else branch
- show() tracks reactive dependencies (condition getter)
- show() cleans up properly when returned Cleanup is called
- 7+ tests covering core functionality
- All 421+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-control-flow/06-01-SUMMARY.md`
</output>
