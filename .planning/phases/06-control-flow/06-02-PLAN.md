---
phase: 06-control-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/primitives/control_flow.rs
  - src/primitives/mod.rs
autonomous: true

must_haves:
  truths:
    - "each() renders component for each item in list"
    - "each() creates new components only for new items (by key)"
    - "each() destroys components for removed items"
    - "each() updates item signals for existing items (fine-grained)"
    - "each() provides reactive item getter to render function"
    - "each() cleans up all components when stopped"
  artifacts:
    - path: "src/primitives/control_flow.rs"
      provides: "each() list rendering function"
      exports: ["each"]
      min_lines: 150
  key_links:
    - from: "src/primitives/control_flow.rs:each"
      to: "spark_signals::signal"
      via: "Per-item signals for fine-grained reactivity"
      pattern: "signal\\("
    - from: "src/primitives/control_flow.rs:each"
      to: "HashMap"
      via: "Key-to-cleanup and key-to-signal maps"
      pattern: "HashMap::<.*,.*Cleanup"
---

<objective>
Implement each() list rendering primitive with fine-grained reactivity.

Purpose: Enable efficient list rendering where adding/removing items only affects those specific items. Uses per-item signals so item updates don't recreate components. This is the core pattern for performant dynamic lists.

Output: Working each() function that tracks items by key, creates per-item signals, and performs minimal DOM updates on list changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-control-flow/06-CONTEXT.md
@.planning/phases/06-control-flow/06-RESEARCH.md

# TypeScript reference
@/Users/rusty/Documents/Projects/TUI/tui/src/primitives/each.ts

# Rust patterns to follow
@src/primitives/types.rs (Cleanup type)
@src/engine/registry.rs (parent context stack)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement each() with key-based reconciliation</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
Add the `each()` function to `src/primitives/control_flow.rs`:

1. **Additional imports:**
   - `spark_signals::signal` (for per-item signals)
   - `std::collections::{HashMap, HashSet}`
   - `std::hash::Hash`

2. **Function signature:**
   ```rust
   pub fn each<T, K, RenderF, R>(
       items_getter: impl Fn() -> Vec<T> + 'static,
       render_fn: RenderF,
       key_fn: impl Fn(&T) -> K + 'static,
   ) -> Cleanup
   where
       T: Clone + PartialEq + 'static,
       K: Clone + Eq + Hash + std::fmt::Debug + 'static,
       RenderF: Fn(Rc<dyn Fn() -> T>, K) -> R + Clone + 'static,
       R: Into<Cleanup>,
   ```

3. **Implementation pattern (from TypeScript each.ts):**
   - Capture parent index at creation time
   - Create `effect_scope()` for cleanup management
   - Create `Rc<RefCell<HashMap<K, Cleanup>>>` for cleanups by key
   - Create `Rc<RefCell<HashMap<K, Signal<T>>>>` for item signals by key
   - Inside `scope.run()`:
     - Create effect that:
       a. Reads items via `items_getter()` (establishes dependency)
       b. Builds `HashSet<K>` of current keys
       c. Push parent context
       d. For each item:
          - Get key via `key_fn(&item)`
          - Warn on duplicate keys (like TypeScript)
          - If key NOT in item_signals: NEW item
            - Create `signal(item.clone())`
            - Create getter: `Rc::new(move || sig.get())`
            - Call `render_fn(getter, key.clone()).into()`
            - Store signal and cleanup in maps
          - If key IS in item_signals: EXISTING item
            - Update signal: `sig.set(item.clone())`
       e. Pop parent context
       f. Cleanup removed items: for each key in cleanups not in current_keys, call cleanup and remove from both maps
     - Register `on_scope_dispose()` to cleanup all remaining items
   - Return `Box::new(move || scope.stop())`

4. **Borrow management:** The tricky part is borrowing cleanups/item_signals inside the effect. Use pattern:
   ```rust
   let cleanups_effect = cleanups.clone();
   let item_signals_effect = item_signals.clone();
   let cleanups_dispose = cleanups.clone();
   ```

5. **Duplicate key warning:** Use `eprintln!` (like TypeScript's console.warn) to warn about duplicate keys without crashing.

6. **Update `src/primitives/mod.rs`:**
   - Add `pub use control_flow::each;`
  </action>
  <verify>
`cargo check -p spark-tui` compiles without errors.
  </verify>
  <done>
each() function exists with correct signature and key-based reconciliation.
Module exports each from primitives.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for each()</name>
  <files>src/primitives/control_flow.rs</files>
  <action>
Add tests to the existing `#[cfg(test)] mod tests` in control_flow.rs:

1. **test_each_renders_all_items:**
   - Create `signal(vec!["a", "b", "c"])` items
   - Call `each(getter, |get_item, key| create_component(), |item| item.to_string())`
   - Verify 3 components created

2. **test_each_adds_new_items:**
   - Start with `signal(vec!["a", "b"])`
   - Call each, verify 2 components
   - Add "c": `items.set(vec!["a", "b", "c"])`
   - Verify 3 components (1 new)

3. **test_each_removes_items:**
   - Start with `signal(vec!["a", "b", "c"])`
   - Call each, verify 3 components
   - Remove "b": `items.set(vec!["a", "c"])`
   - Verify 2 components remaining

4. **test_each_updates_existing_items:**
   - Create struct `Item { id: i32, value: String }`
   - Start with items [Item{id:1, value:"old"}]
   - Call each with key=id, render captures value
   - Update: [Item{id:1, value:"new"}]
   - Verify NO new component created (same key)
   - Verify item signal was updated (can track via effect on the getter)

5. **test_each_cleanup_destroys_all:**
   - Create each with 3 items
   - Call returned cleanup
   - Verify all components destroyed

6. **test_each_empty_list:**
   - Create each with empty vec
   - Verify 0 components, no panic

7. **test_each_reorder_preserves_components:**
   - Start with ["a", "b", "c"]
   - Reorder to ["c", "a", "b"]
   - Verify same 3 components (check they weren't recreated via component count)

8. **test_each_nested_parent_context:**
   - Create parent Box
   - Inside Box children, call each()
   - Verify each's components have correct parent

9. **test_each_duplicate_key_warns:**
   - Create items with duplicate keys (same id)
   - Verify no crash (warning is printed to stderr)

**Helper for Item tests:**
```rust
#[derive(Clone, PartialEq)]
struct TestItem {
    id: i32,
    value: String,
}
```
  </action>
  <verify>
`cargo test -p spark-tui each` runs all each tests and they pass.
  </verify>
  <done>
9+ tests for each() covering add/remove/update/reorder/cleanup.
All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p spark-tui` - no errors
2. `cargo test -p spark-tui each` - all each tests pass
3. `cargo test -p spark-tui` - no regressions (all existing tests pass)
</verification>

<success_criteria>
- each() function exported from spark_tui::primitives
- each() creates component per item with per-item signals
- each() adds new components only for new keys
- each() removes components for removed keys
- each() updates signals for existing keys (no recreation)
- each() handles empty lists without panic
- each() cleans up all on returned Cleanup call
- 9+ tests covering core functionality
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-control-flow/06-02-SUMMARY.md`
</output>
