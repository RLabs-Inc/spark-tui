---
phase: 01-mouse-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state/mouse.rs
  - src/state/mod.rs
  - src/pipeline/mount.rs
autonomous: true

must_haves:
  truths:
    - "MouseEvent type matches TypeScript structure"
    - "HitGrid provides O(1) coordinate-to-component lookup"
    - "Handler registry stores component callbacks"
    - "Dispatch function routes events to handlers"
  artifacts:
    - path: "src/state/mouse.rs"
      provides: "Mouse types, HitGrid, handler registry, dispatch"
      exports: ["MouseEvent", "MouseAction", "MouseButton", "HitGrid", "dispatch", "on_component"]
      min_lines: 200
    - path: "src/state/mod.rs"
      provides: "Mouse module export"
      contains: "pub mod mouse"
  key_links:
    - from: "src/state/mouse.rs"
      to: "src/engine/arrays/interaction.rs"
      via: "set_hovered, set_pressed"
      pattern: "interaction::(set_hovered|set_pressed)"
    - from: "src/pipeline/mount.rs"
      to: "src/state/mouse.rs"
      via: "HitGrid import"
      pattern: "use.*mouse::HitGrid"
---

<objective>
Create the mouse module foundation with types, HitGrid, handler registry, and dispatch logic.

Purpose: Establish the core mouse event infrastructure that parallels the keyboard module, enabling components to register mouse handlers and receive dispatched events.

Output: Working mouse.rs module with HitGrid extracted from mount.rs, MouseEvent types matching TypeScript, handler registry, and dispatch function with hover/click detection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mouse-events/01-RESEARCH.md

# Reference implementation patterns
@src/state/keyboard.rs
@src/pipeline/mount.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mouse.rs with types and HitGrid</name>
  <files>src/state/mouse.rs, src/state/mod.rs</files>
  <action>
    Create `src/state/mouse.rs` with:

    1. **Types** (match TypeScript exactly):
       ```rust
       #[derive(Debug, Clone, PartialEq)]
       pub enum MouseAction { Down, Up, Move, Drag, Scroll }

       #[derive(Debug, Clone, Copy, PartialEq, Eq)]
       pub enum MouseButton { Left, Middle, Right, None }

       #[derive(Debug, Clone, Copy, PartialEq)]
       pub enum ScrollDirection { Up, Down, Left, Right }

       #[derive(Debug, Clone, PartialEq)]
       pub struct MouseEvent {
           pub action: MouseAction,
           pub button: MouseButton,
           pub x: u16,
           pub y: u16,
           pub modifiers: Modifiers,  // Reuse from keyboard.rs
           pub scroll: Option<(ScrollDirection, u16)>,
           pub component_index: Option<usize>,
       }
       ```

    2. **HitGrid** (MOVE from mount.rs, don't duplicate):
       - Move the existing HitGrid struct and impl from `src/pipeline/mount.rs`
       - Make it `pub` for external access
       - Add thread_local! for global access: `static HIT_GRID: RefCell<HitGrid>`
       - Add `pub fn resize_hit_grid(w, h)` and `pub fn update_hit_grid(regions: &[HitRegion])`

    3. **Reactive State** (thread_local! signals like keyboard.rs):
       ```rust
       static LAST_EVENT: Signal<Option<MouseEvent>>
       static MOUSE_X: Signal<u16>
       static MOUSE_Y: Signal<u16>
       static IS_MOUSE_DOWN: Signal<bool>
       static HOVERED_COMPONENT: Signal<Option<usize>>
       static PRESSED_COMPONENT: Signal<Option<usize>>
       ```

    4. **Public accessors**:
       ```rust
       pub fn last_event() -> Option<MouseEvent>
       pub fn mouse_x() -> u16
       pub fn mouse_y() -> u16
       pub fn is_mouse_down() -> bool
       pub fn hovered_component() -> Option<usize>
       ```

    Update `src/state/mod.rs` to add `pub mod mouse;`

    Use keyboard.rs as the structural pattern - same thread_local! approach, same cleanup patterns.
  </action>
  <verify>
    `cargo check -p spark-tui` compiles without errors.
    Types are exported from `spark_tui::state::mouse`.
  </verify>
  <done>
    MouseEvent, MouseAction, MouseButton types exist.
    HitGrid moved to mouse.rs with thread_local! storage.
    Reactive state signals exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create handler registry and dispatch</name>
  <files>src/state/mouse.rs</files>
  <action>
    Add to `src/state/mouse.rs`:

    1. **Handler Types**:
       ```rust
       pub type MouseHandler = Box<dyn Fn(&MouseEvent) -> bool>;

       pub struct MouseHandlers {
           pub on_mouse_down: Option<MouseHandler>,
           pub on_mouse_up: Option<MouseHandler>,
           pub on_click: Option<MouseHandler>,
           pub on_mouse_enter: Option<Box<dyn Fn(&MouseEvent)>>,  // No return
           pub on_mouse_leave: Option<Box<dyn Fn(&MouseEvent)>>,  // No return
           pub on_scroll: Option<MouseHandler>,
       }
       ```

    2. **Registry** (mirror keyboard.rs pattern):
       ```rust
       struct HandlerRegistry {
           component_handlers: HashMap<usize, MouseHandlers>,
           global_down_handlers: Vec<(usize, MouseHandler)>,
           global_up_handlers: Vec<(usize, MouseHandler)>,
           global_click_handlers: Vec<(usize, MouseHandler)>,
           next_id: usize,
       }

       thread_local! {
           static REGISTRY: RefCell<HandlerRegistry> = ...
       }
       ```

    3. **Registration API**:
       ```rust
       /// Register handlers for a component. Returns cleanup function.
       pub fn on_component(index: usize, handlers: MouseHandlers) -> impl FnOnce() {
           // Insert into registry, return closure that removes
       }

       /// Register global mouse down handler.
       pub fn on_mouse_down<F>(handler: F) -> impl FnOnce()
       where F: Fn(&MouseEvent) -> bool + 'static

       /// Same for on_mouse_up, on_click
       ```

    4. **Dispatch Function**:
       ```rust
       pub fn dispatch(mut event: MouseEvent) -> bool {
           // 1. Lookup component from HitGrid
           event.component_index = HIT_GRID.with(|g| g.borrow().get(event.x, event.y));

           // 2. Update reactive state
           LAST_EVENT.with(|s| s.set(Some(event.clone())));
           MOUSE_X.with(|s| s.set(event.x));
           MOUSE_Y.with(|s| s.set(event.y));

           // 3. Handle hover (enter/leave)
           let prev_hovered = HOVERED_COMPONENT.with(|s| s.get());
           if event.component_index != prev_hovered {
               // Fire leave on prev, enter on new
               // Update interaction arrays
           }

           // 4. Handle down/up/click
           match event.action {
               MouseAction::Down => { /* track pressed, fire handlers */ }
               MouseAction::Up => { /* detect click, fire handlers */ }
               MouseAction::Scroll => { /* fire scroll handlers */ }
               _ => {}
           }

           consumed
       }
       ```

    5. **Cleanup functions**:
       ```rust
       pub fn cleanup_index(index: usize)  // Remove handlers for component
       pub fn cleanup()  // Clear all state
       pub fn reset_mouse_state()  // For testing
       ```

    Follow keyboard.rs patterns exactly for handler ID generation and cleanup.
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `cargo test -p spark-tui mouse` runs (will add tests in next task).
  </verify>
  <done>
    Handler registry stores component callbacks.
    on_component returns cleanup function.
    dispatch routes events and updates state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update mount.rs and add tests</name>
  <files>src/pipeline/mount.rs, src/state/mouse.rs</files>
  <action>
    1. **Update mount.rs**:
       - Remove HitGrid struct and impl (now in mouse.rs)
       - Add `use crate::state::mouse::{self, HitGrid};`
       - In render effects, replace local hit_grid with:
         ```rust
         // Resize/clear the shared HitGrid
         mouse::resize_hit_grid(tw, th);

         // Apply hit regions
         for region in &result.hit_regions {
             mouse::fill_hit_rect(
                 region.x, region.y,
                 region.width, region.height,
                 region.component_index,
             );
         }
         ```
       - Add helper functions to mouse.rs if needed:
         ```rust
         pub fn resize_hit_grid(width: u16, height: u16)
         pub fn clear_hit_grid()
         pub fn fill_hit_rect(x: u16, y: u16, w: u16, h: u16, index: usize)
         ```

    2. **Add comprehensive tests to mouse.rs**:
       ```rust
       #[cfg(test)]
       mod tests {
           // Test HitGrid basics
           fn test_hit_grid_get_set()
           fn test_hit_grid_resize()
           fn test_hit_grid_out_of_bounds()

           // Test handler registration
           fn test_on_component_registration()
           fn test_handler_cleanup()

           // Test dispatch
           fn test_dispatch_updates_state()
           fn test_hover_detection()
           fn test_click_detection()
           fn test_scroll_dispatch()
       }
       ```

    3. **Ensure mount.rs tests still pass**:
       - The hit_grid tests in mount.rs need to work with the new import

    Match the test style from keyboard.rs (use Rc<Cell<>> for tracking calls).
  </action>
  <verify>
    `cargo test -p spark-tui -- --test-threads=1` passes all tests.
    `cargo test -p spark-tui mouse` passes.
    `cargo test -p spark-tui mount` passes.
  </verify>
  <done>
    HitGrid moved out of mount.rs.
    mount.rs uses mouse module for hit detection.
    Comprehensive tests for mouse module.
    All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify module exports: `use spark_tui::state::mouse::{MouseEvent, dispatch, on_component};`
4. Check HitGrid is no longer duplicated (only in mouse.rs)
</verification>

<success_criteria>
- MouseEvent type exists with action, button, x, y, modifiers, scroll, component_index
- HitGrid provides O(1) lookup, moved from mount.rs to mouse.rs
- Handler registry stores per-component and global handlers
- dispatch() updates reactive state and fires appropriate handlers
- Hover enter/leave detection works
- Click detection (down + up on same component) works
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-mouse-events/01-01-SUMMARY.md`
</output>
