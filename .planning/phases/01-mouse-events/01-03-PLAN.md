---
phase: 01-mouse-events
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/primitives/types.rs
  - src/primitives/box_primitive.rs
  - src/primitives/text.rs
autonomous: true

must_haves:
  truths:
    - "BoxProps accepts onClick, onMouseDown, onMouseUp, onMouseEnter, onMouseLeave, onScroll callbacks"
    - "box_primitive registers mouse handlers when callbacks provided"
    - "Focusable boxes get click-to-focus behavior"
    - "TextProps accepts onClick callback"
  artifacts:
    - path: "src/primitives/types.rs"
      provides: "Callback props on BoxProps and TextProps"
      contains: "on_click"
    - path: "src/primitives/box_primitive.rs"
      provides: "Mouse handler registration and cleanup"
      contains: "mouse::on_component"
  key_links:
    - from: "src/primitives/box_primitive.rs"
      to: "src/state/mouse.rs"
      via: "on_component registration"
      pattern: "mouse::on_component"
    - from: "src/primitives/box_primitive.rs"
      to: "src/state/focus.rs"
      via: "click-to-focus"
      pattern: "focus::focus"
---

<objective>
Add mouse callback props to BoxProps and TextProps, and wire them in the primitive implementations.

Purpose: Enable components to respond to mouse interactions by accepting callback props and registering them with the mouse module.

Output: BoxProps with onClick/onMouse* callbacks, box_primitive that registers handlers and implements click-to-focus, TextProps with onClick.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-mouse-events/01-RESEARCH.md
@.planning/phases/01-mouse-events/01-01-SUMMARY.md

# Files to modify
@src/primitives/types.rs
@src/primitives/box_primitive.rs
@src/primitives/text.rs

# Mouse module for handler registration
@src/state/mouse.rs
@src/state/focus.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mouse callback props to BoxProps</name>
  <files>src/primitives/types.rs</files>
  <action>
    Update `src/primitives/types.rs`:

    1. **Add imports at top**:
       ```rust
       use crate::state::mouse::MouseEvent;
       use crate::state::keyboard::KeyboardEvent;
       ```

    2. **Add callback type aliases** (after Cleanup type):
       ```rust
       /// Mouse event callback type
       pub type MouseCallback = Box<dyn Fn(&MouseEvent)>;

       /// Mouse event callback that can consume the event
       pub type MouseCallbackConsuming = Box<dyn Fn(&MouseEvent) -> bool>;

       /// Keyboard event callback
       pub type KeyCallback = Box<dyn Fn(&KeyboardEvent) -> bool>;
       ```

    3. **Add callback fields to BoxProps** (in the Interaction section):
       ```rust
       // =========================================================================
       // Event Callbacks
       // =========================================================================

       /// Click callback (fires on mouse up if down was on same component).
       pub on_click: Option<MouseCallback>,

       /// Mouse down callback.
       pub on_mouse_down: Option<MouseCallback>,

       /// Mouse up callback.
       pub on_mouse_up: Option<MouseCallback>,

       /// Mouse enter callback (hover starts).
       pub on_mouse_enter: Option<MouseCallback>,

       /// Mouse leave callback (hover ends).
       pub on_mouse_leave: Option<MouseCallback>,

       /// Scroll callback (mouse wheel).
       pub on_scroll: Option<MouseCallbackConsuming>,

       /// Keyboard callback (when focused).
       pub on_key: Option<KeyCallback>,
       ```

    4. **Update Default impl for BoxProps** to include the new fields as None:
       The struct derives Default, so Option fields default to None automatically.
       Just ensure the struct is still valid after adding fields.
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    BoxProps has on_click, on_mouse_down, on_mouse_up, on_mouse_enter, on_mouse_leave, on_scroll, on_key fields.
  </verify>
  <done>
    MouseCallback and KeyCallback types defined.
    BoxProps has all mouse and keyboard callback props.
    Defaults remain None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire mouse handlers in box_primitive</name>
  <files>src/primitives/box_primitive.rs</files>
  <action>
    Update `src/primitives/box_primitive.rs`:

    1. **Add imports**:
       ```rust
       use crate::state::{mouse, focus, keyboard};
       ```

    2. **After interaction setup (section 7), add mouse handler registration** (new section 8):
       ```rust
       // 8. REGISTER MOUSE HANDLERS

       let has_mouse_handlers = props.on_click.is_some()
           || props.on_mouse_down.is_some()
           || props.on_mouse_up.is_some()
           || props.on_mouse_enter.is_some()
           || props.on_mouse_leave.is_some()
           || props.on_scroll.is_some();

       let mut mouse_cleanup: Option<Box<dyn FnOnce()>> = None;
       let mut key_cleanup: Option<Box<dyn FnOnce()>> = None;

       if should_be_focusable || has_mouse_handlers {
           // Build click handler that includes click-to-focus
           let user_on_click = props.on_click;
           let click_handler: Option<Box<dyn Fn(&mouse::MouseEvent)>> = if should_be_focusable {
               Some(Box::new(move |event: &mouse::MouseEvent| {
                   focus::focus(index);
                   if let Some(ref handler) = user_on_click {
                       handler(event);
                   }
               }))
           } else {
               user_on_click
           };

           let handlers = mouse::MouseHandlers {
               on_mouse_down: props.on_mouse_down,
               on_mouse_up: props.on_mouse_up,
               on_click: click_handler,
               on_mouse_enter: props.on_mouse_enter,
               on_mouse_leave: props.on_mouse_leave,
               on_scroll: props.on_scroll,
           };

           let cleanup_fn = mouse::on_component(index, handlers);
           mouse_cleanup = Some(Box::new(cleanup_fn));
       }
       ```

    3. **Add keyboard handler registration**:
       ```rust
       // 9. REGISTER KEYBOARD HANDLER (if focusable and has on_key)

       if should_be_focusable {
           if let Some(on_key) = props.on_key {
               let cleanup_fn = keyboard::on_focused(index, move |event| {
                   on_key(event)
               });
               key_cleanup = Some(Box::new(cleanup_fn));
           }
       }
       ```

    4. **Update cleanup to release handlers**:
       ```rust
       // 10. RENDER CHILDREN (was 8)
       if let Some(children) = props.children {
           push_parent_context(index);
           children();
           pop_parent_context();
       }

       // 11. RETURN CLEANUP (was 9)
       Box::new(move || {
           // Clean up mouse handlers
           if let Some(cleanup) = mouse_cleanup {
               cleanup();
           }
           // Clean up keyboard handlers
           if let Some(cleanup) = key_cleanup {
               cleanup();
           }
           // Clean up component index
           mouse::cleanup_index(index);
           keyboard::cleanup_index(index);
           // Release index
           release_index(index);
       })
       ```

    NOTE: The closure captures may need adjustment for ownership. Use move semantics carefully.
    If on_click needs to be optional in MouseHandlers, adjust types accordingly.
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    No ownership/borrow errors.
  </verify>
  <done>
    box_primitive registers mouse handlers via mouse::on_component.
    Focusable boxes get click-to-focus wrapped into on_click.
    Keyboard handlers registered via keyboard::on_focused.
    Cleanup function releases all handlers and index.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add onClick to TextProps and wire in text primitive</name>
  <files>src/primitives/types.rs, src/primitives/text.rs</files>
  <action>
    1. **Update TextProps in types.rs**:
       Add after the existing interaction section (or create one):
       ```rust
       // =========================================================================
       // Event Callbacks
       // =========================================================================

       /// Click callback for clickable text.
       pub on_click: Option<MouseCallback>,
       ```

       Update the Default impl to include `on_click: None`.

    2. **Update text.rs** to register click handler:

       Add imports:
       ```rust
       use crate::state::mouse;
       ```

       After setting up the component, add:
       ```rust
       // Register mouse handler if onClick provided
       let mut mouse_cleanup: Option<Box<dyn FnOnce()>> = None;

       if let Some(on_click) = props.on_click {
           let handlers = mouse::MouseHandlers {
               on_mouse_down: None,
               on_mouse_up: None,
               on_click: Some(on_click),
               on_mouse_enter: None,
               on_mouse_leave: None,
               on_scroll: None,
           };
           let cleanup_fn = mouse::on_component(index, handlers);
           mouse_cleanup = Some(Box::new(cleanup_fn));
       }
       ```

       Update cleanup:
       ```rust
       Box::new(move || {
           if let Some(cleanup) = mouse_cleanup {
               cleanup();
           }
           mouse::cleanup_index(index);
           release_index(index);
       })
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    TextProps has on_click field.
  </verify>
  <done>
    TextProps has on_click callback.
    text primitive registers click handler when provided.
    Cleanup releases handler.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify BoxProps accepts: on_click, on_mouse_down, on_mouse_up, on_mouse_enter, on_mouse_leave, on_scroll, on_key
4. Verify TextProps accepts: on_click
5. Create a simple test that passes callbacks and verify registration
</verification>

<success_criteria>
- BoxProps has all mouse callback props (on_click, on_mouse_down, on_mouse_up, on_mouse_enter, on_mouse_leave, on_scroll)
- BoxProps has on_key for keyboard events when focused
- box_primitive registers handlers via mouse::on_component when callbacks provided
- Focusable boxes auto-focus on click (click-to-focus)
- TextProps has on_click callback
- text primitive registers click handler when on_click provided
- Cleanup releases all handlers and component index
</success_criteria>

<output>
After completion, create `.planning/phases/01-mouse-events/01-03-SUMMARY.md`
</output>
