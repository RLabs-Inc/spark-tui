---
phase: 01-mouse-events
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/state/input.rs
  - src/state/mod.rs
autonomous: true

must_haves:
  truths:
    - "crossterm MouseEvent converts to our MouseEvent"
    - "crossterm KeyEvent converts to our KeyboardEvent"
    - "Event polling integrates with existing infrastructure"
  artifacts:
    - path: "src/state/input.rs"
      provides: "Event conversion and routing"
      exports: ["convert_mouse_event", "convert_key_event", "poll_event", "read_event"]
      min_lines: 100
    - path: "src/state/mod.rs"
      provides: "Input module export"
      contains: "pub mod input"
  key_links:
    - from: "src/state/input.rs"
      to: "src/state/mouse.rs"
      via: "MouseEvent import"
      pattern: "use.*mouse::(MouseEvent|MouseAction|MouseButton)"
    - from: "src/state/input.rs"
      to: "src/state/keyboard.rs"
      via: "KeyboardEvent import"
      pattern: "use.*keyboard::(KeyboardEvent|Modifiers)"
---

<objective>
Create the input module that converts crossterm events to our types and provides event polling.

Purpose: Bridge crossterm's event system with our mouse and keyboard modules, enabling the event loop to receive and route terminal events.

Output: Working input.rs that converts crossterm::event::MouseEvent to our MouseEvent, crossterm::event::KeyEvent to KeyboardEvent, and provides polling functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-mouse-events/01-RESEARCH.md
@.planning/phases/01-mouse-events/01-01-SUMMARY.md

# Types to convert to
@src/state/mouse.rs
@src/state/keyboard.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input.rs with crossterm event conversion</name>
  <files>src/state/input.rs, src/state/mod.rs</files>
  <action>
    Create `src/state/input.rs` with:

    1. **Imports**:
       ```rust
       use crossterm::event::{
           Event as CrosstermEvent,
           MouseEvent as CrosstermMouseEvent,
           MouseEventKind, MouseButton as CrosstermMouseButton,
           KeyEvent as CrosstermKeyEvent,
           KeyCode, KeyModifiers,
           poll, read,
       };
       use std::time::Duration;

       use super::mouse::{MouseEvent, MouseAction, MouseButton, ScrollDirection};
       use super::keyboard::{KeyboardEvent, KeyState, Modifiers};
       ```

    2. **Mouse Event Conversion**:
       ```rust
       /// Convert crossterm MouseEvent to our MouseEvent
       pub fn convert_mouse_event(event: CrosstermMouseEvent) -> MouseEvent {
           let (action, button) = match event.kind {
               MouseEventKind::Down(btn) => (MouseAction::Down, convert_mouse_button(btn)),
               MouseEventKind::Up(btn) => (MouseAction::Up, convert_mouse_button(btn)),
               MouseEventKind::Drag(btn) => (MouseAction::Drag, convert_mouse_button(btn)),
               MouseEventKind::Moved => (MouseAction::Move, MouseButton::None),
               MouseEventKind::ScrollUp => (MouseAction::Scroll, MouseButton::None),
               MouseEventKind::ScrollDown => (MouseAction::Scroll, MouseButton::None),
               MouseEventKind::ScrollLeft => (MouseAction::Scroll, MouseButton::None),
               MouseEventKind::ScrollRight => (MouseAction::Scroll, MouseButton::None),
           };

           let scroll = match event.kind {
               MouseEventKind::ScrollUp => Some((ScrollDirection::Up, 1)),
               MouseEventKind::ScrollDown => Some((ScrollDirection::Down, 1)),
               MouseEventKind::ScrollLeft => Some((ScrollDirection::Left, 1)),
               MouseEventKind::ScrollRight => Some((ScrollDirection::Right, 1)),
               _ => None,
           };

           MouseEvent {
               action,
               button,
               x: event.column,
               y: event.row,
               modifiers: convert_modifiers(event.modifiers),
               scroll,
               component_index: None,  // Filled by dispatch
           }
       }

       fn convert_mouse_button(btn: CrosstermMouseButton) -> MouseButton {
           match btn {
               CrosstermMouseButton::Left => MouseButton::Left,
               CrosstermMouseButton::Right => MouseButton::Right,
               CrosstermMouseButton::Middle => MouseButton::Middle,
           }
       }
       ```

    3. **Key Event Conversion**:
       ```rust
       /// Convert crossterm KeyEvent to our KeyboardEvent
       pub fn convert_key_event(event: CrosstermKeyEvent) -> KeyboardEvent {
           let key = match event.code {
               KeyCode::Char(c) => c.to_string(),
               KeyCode::Enter => "Enter".to_string(),
               KeyCode::Tab => "Tab".to_string(),
               KeyCode::Backspace => "Backspace".to_string(),
               KeyCode::Delete => "Delete".to_string(),
               KeyCode::Esc => "Escape".to_string(),
               KeyCode::Up => "ArrowUp".to_string(),
               KeyCode::Down => "ArrowDown".to_string(),
               KeyCode::Left => "ArrowLeft".to_string(),
               KeyCode::Right => "ArrowRight".to_string(),
               KeyCode::Home => "Home".to_string(),
               KeyCode::End => "End".to_string(),
               KeyCode::PageUp => "PageUp".to_string(),
               KeyCode::PageDown => "PageDown".to_string(),
               KeyCode::F(n) => format!("F{}", n),
               KeyCode::Insert => "Insert".to_string(),
               KeyCode::Null => "".to_string(),
               _ => "".to_string(),
           };

           let state = match event.kind {
               crossterm::event::KeyEventKind::Press => KeyState::Press,
               crossterm::event::KeyEventKind::Repeat => KeyState::Repeat,
               crossterm::event::KeyEventKind::Release => KeyState::Release,
           };

           KeyboardEvent {
               key,
               modifiers: convert_modifiers(event.modifiers),
               state,
               raw: None,
           }
       }
       ```

    4. **Modifier Conversion** (shared helper):
       ```rust
       fn convert_modifiers(mods: KeyModifiers) -> Modifiers {
           Modifiers {
               ctrl: mods.contains(KeyModifiers::CONTROL),
               alt: mods.contains(KeyModifiers::ALT),
               shift: mods.contains(KeyModifiers::SHIFT),
               meta: false,  // Not exposed by crossterm
           }
       }
       ```

    Update `src/state/mod.rs` to add `pub mod input;`
  </action>
  <verify>
    `cargo check -p spark-tui` compiles without errors.
    Functions are exported from `spark_tui::state::input`.
  </verify>
  <done>
    convert_mouse_event converts crossterm MouseEvent to our MouseEvent.
    convert_key_event converts crossterm KeyEvent to KeyboardEvent.
    All mouse actions and scroll directions handled.
    All common key codes mapped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add event polling and routing API</name>
  <files>src/state/input.rs</files>
  <action>
    Add to `src/state/input.rs`:

    1. **Our Event Enum**:
       ```rust
       /// Unified event type for our framework
       #[derive(Debug, Clone)]
       pub enum InputEvent {
           Mouse(MouseEvent),
           Key(KeyboardEvent),
           Resize(u16, u16),
           None,
       }
       ```

    2. **Polling Function**:
       ```rust
       /// Poll for an event with timeout.
       /// Returns None if no event within timeout.
       pub fn poll_event(timeout: Duration) -> std::io::Result<Option<InputEvent>> {
           if poll(timeout)? {
               Ok(Some(read_event()?))
           } else {
               Ok(None)
           }
       }

       /// Read the next event (blocking).
       pub fn read_event() -> std::io::Result<InputEvent> {
           match read()? {
               CrosstermEvent::Mouse(mouse) => Ok(InputEvent::Mouse(convert_mouse_event(mouse))),
               CrosstermEvent::Key(key) => Ok(InputEvent::Key(convert_key_event(key))),
               CrosstermEvent::Resize(w, h) => Ok(InputEvent::Resize(w, h)),
               _ => Ok(InputEvent::None),
           }
       }
       ```

    3. **Route and Dispatch Helper**:
       ```rust
       /// Route an event to the appropriate handler.
       /// Returns true if consumed.
       pub fn route_event(event: InputEvent) -> bool {
           match event {
               InputEvent::Mouse(mouse) => super::mouse::dispatch(mouse),
               InputEvent::Key(key) => super::keyboard::dispatch(key),
               InputEvent::Resize(w, h) => {
                   // Update terminal size signal
                   crate::pipeline::terminal::set_terminal_size(w, h);
                   false
               }
               InputEvent::None => false,
           }
       }
       ```

    4. **Mouse Enable/Disable**:
       ```rust
       use crossterm::execute;
       use crossterm::event::{EnableMouseCapture, DisableMouseCapture};
       use std::io::stdout;

       /// Enable mouse capture.
       pub fn enable_mouse() -> std::io::Result<()> {
           execute!(stdout(), EnableMouseCapture)
       }

       /// Disable mouse capture.
       pub fn disable_mouse() -> std::io::Result<()> {
           execute!(stdout(), DisableMouseCapture)
       }
       ```

    NOTE: If terminal::set_terminal_size doesn't exist yet, add it or just call detect_terminal_size. Check what's available in terminal.rs first.
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `poll_event`, `read_event`, `route_event` are exported.
  </verify>
  <done>
    InputEvent enum unifies mouse, key, resize events.
    poll_event provides non-blocking event check.
    read_event provides blocking event read.
    route_event dispatches to appropriate module.
    enable_mouse/disable_mouse control mouse capture.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for event conversion</name>
  <files>src/state/input.rs</files>
  <action>
    Add comprehensive tests to `src/state/input.rs`:

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_convert_mouse_down() {
            let crossterm_event = CrosstermMouseEvent {
                kind: MouseEventKind::Down(CrosstermMouseButton::Left),
                column: 10,
                row: 5,
                modifiers: KeyModifiers::empty(),
            };

            let event = convert_mouse_event(crossterm_event);

            assert_eq!(event.action, MouseAction::Down);
            assert_eq!(event.button, MouseButton::Left);
            assert_eq!(event.x, 10);
            assert_eq!(event.y, 5);
            assert!(!event.modifiers.ctrl);
            assert!(event.scroll.is_none());
        }

        #[test]
        fn test_convert_mouse_scroll() {
            let crossterm_event = CrosstermMouseEvent {
                kind: MouseEventKind::ScrollDown,
                column: 0,
                row: 0,
                modifiers: KeyModifiers::empty(),
            };

            let event = convert_mouse_event(crossterm_event);

            assert_eq!(event.action, MouseAction::Scroll);
            assert_eq!(event.scroll, Some((ScrollDirection::Down, 1)));
        }

        #[test]
        fn test_convert_mouse_with_modifiers() {
            let crossterm_event = CrosstermMouseEvent {
                kind: MouseEventKind::Down(CrosstermMouseButton::Left),
                column: 0,
                row: 0,
                modifiers: KeyModifiers::CONTROL | KeyModifiers::SHIFT,
            };

            let event = convert_mouse_event(crossterm_event);

            assert!(event.modifiers.ctrl);
            assert!(event.modifiers.shift);
            assert!(!event.modifiers.alt);
        }

        #[test]
        fn test_convert_key_char() {
            let crossterm_event = CrosstermKeyEvent {
                code: KeyCode::Char('a'),
                modifiers: KeyModifiers::empty(),
                kind: crossterm::event::KeyEventKind::Press,
                state: crossterm::event::KeyEventState::NONE,
            };

            let event = convert_key_event(crossterm_event);

            assert_eq!(event.key, "a");
            assert_eq!(event.state, KeyState::Press);
        }

        #[test]
        fn test_convert_key_special() {
            let crossterm_event = CrosstermKeyEvent {
                code: KeyCode::Enter,
                modifiers: KeyModifiers::empty(),
                kind: crossterm::event::KeyEventKind::Press,
                state: crossterm::event::KeyEventState::NONE,
            };

            let event = convert_key_event(crossterm_event);
            assert_eq!(event.key, "Enter");

            // Test arrow keys
            let crossterm_event = CrosstermKeyEvent {
                code: KeyCode::Up,
                modifiers: KeyModifiers::empty(),
                kind: crossterm::event::KeyEventKind::Press,
                state: crossterm::event::KeyEventState::NONE,
            };

            let event = convert_key_event(crossterm_event);
            assert_eq!(event.key, "ArrowUp");
        }

        #[test]
        fn test_convert_key_with_ctrl() {
            let crossterm_event = CrosstermKeyEvent {
                code: KeyCode::Char('c'),
                modifiers: KeyModifiers::CONTROL,
                kind: crossterm::event::KeyEventKind::Press,
                state: crossterm::event::KeyEventState::NONE,
            };

            let event = convert_key_event(crossterm_event);

            assert_eq!(event.key, "c");
            assert!(event.modifiers.ctrl);
        }

        #[test]
        fn test_all_mouse_buttons() {
            assert_eq!(convert_mouse_button(CrosstermMouseButton::Left), MouseButton::Left);
            assert_eq!(convert_mouse_button(CrosstermMouseButton::Right), MouseButton::Right);
            assert_eq!(convert_mouse_button(CrosstermMouseButton::Middle), MouseButton::Middle);
        }
    }
    ```

    Ensure tests compile and run without needing actual terminal interaction.
  </action>
  <verify>
    `cargo test -p spark-tui input` - All tests pass.
    `cargo test -p spark-tui -- --test-threads=1` - All tests pass.
  </verify>
  <done>
    Mouse down/up/scroll conversion tested.
    Key character and special key conversion tested.
    Modifier conversion tested.
    All button types tested.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify exports: `use spark_tui::state::input::{InputEvent, poll_event, route_event};`
4. Check crossterm types convert correctly in tests
</verification>

<success_criteria>
- crossterm MouseEvent converts to our MouseEvent with correct action, button, position, modifiers, scroll
- crossterm KeyEvent converts to our KeyboardEvent with correct key string, state, modifiers
- poll_event provides non-blocking event check with timeout
- read_event provides blocking event read
- route_event dispatches to mouse::dispatch or keyboard::dispatch
- enable_mouse/disable_mouse work
- All conversion tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-mouse-events/01-02-SUMMARY.md`
</output>
