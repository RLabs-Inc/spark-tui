---
phase: 01-mouse-events
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/pipeline/mount.rs
  - src/state/global_keys.rs
  - src/state/mod.rs
autonomous: true

must_haves:
  truths:
    - "Mount enables mouse capture on startup"
    - "Event loop polls for input and dispatches"
    - "Ctrl+C triggers graceful shutdown"
    - "Tab/Shift+Tab cycles focus"
    - "Unmount disables mouse capture"
  artifacts:
    - path: "src/pipeline/mount.rs"
      provides: "Event loop integration"
      contains: "enable_mouse"
    - path: "src/state/global_keys.rs"
      provides: "Global key handlers"
      exports: ["setup_global_keys", "cleanup_global_keys"]
  key_links:
    - from: "src/pipeline/mount.rs"
      to: "src/state/input.rs"
      via: "poll_event, route_event"
      pattern: "input::(poll_event|route_event|enable_mouse)"
    - from: "src/state/global_keys.rs"
      to: "src/state/keyboard.rs"
      via: "on_key handler"
      pattern: "keyboard::on_key"
    - from: "src/state/global_keys.rs"
      to: "src/state/focus.rs"
      via: "focus_next, focus_prev"
      pattern: "focus::(focus_next|focus_prev)"
---

<objective>
Integrate event polling into mount and create global key handlers for Ctrl+C and Tab navigation.

Purpose: Complete the event system by enabling mouse capture on mount, running an event loop that polls and dispatches events, and providing global keyboard shortcuts.

Output: Mount enables mouse, polls events, and routes them. Global keys module handles Ctrl+C shutdown and Tab focus cycling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-mouse-events/01-RESEARCH.md
@.planning/phases/01-mouse-events/01-01-SUMMARY.md
@.planning/phases/01-mouse-events/01-02-SUMMARY.md
@.planning/phases/01-mouse-events/01-03-SUMMARY.md

# Files to modify/create
@src/pipeline/mount.rs
@src/state/focus.rs
@src/state/keyboard.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global_keys.rs with Ctrl+C and Tab handlers</name>
  <files>src/state/global_keys.rs, src/state/mod.rs</files>
  <action>
    Create `src/state/global_keys.rs`:

    ```rust
    //! Global Keys Module - Global keyboard shortcuts
    //!
    //! Provides global key handlers for:
    //! - Ctrl+C: Graceful shutdown
    //! - Tab: Focus next component
    //! - Shift+Tab: Focus previous component
    //!
    //! These handlers are registered on mount and cleaned up on unmount.

    use std::sync::atomic::{AtomicBool, Ordering};
    use std::sync::Arc;

    use super::keyboard;
    use super::focus;

    /// Cleanup handle for global key handlers
    pub struct GlobalKeysHandle {
        ctrl_c_cleanup: Option<Box<dyn FnOnce()>>,
        tab_cleanup: Option<Box<dyn FnOnce()>>,
        shift_tab_cleanup: Option<Box<dyn FnOnce()>>,
    }

    impl GlobalKeysHandle {
        /// Clean up all global key handlers
        pub fn cleanup(mut self) {
            if let Some(cleanup) = self.ctrl_c_cleanup.take() {
                cleanup();
            }
            if let Some(cleanup) = self.tab_cleanup.take() {
                cleanup();
            }
            if let Some(cleanup) = self.shift_tab_cleanup.take() {
                cleanup();
            }
        }
    }

    /// Set up global key handlers.
    /// Returns a handle for cleanup.
    ///
    /// # Arguments
    /// * `running` - Atomic bool to set to false on Ctrl+C
    pub fn setup_global_keys(running: Arc<AtomicBool>) -> GlobalKeysHandle {
        // Ctrl+C - Graceful shutdown
        let running_clone = running.clone();
        let ctrl_c_cleanup = keyboard::on(move |event| {
            if event.modifiers.ctrl && event.key == "c" {
                running_clone.store(false, Ordering::SeqCst);
                true // Consume
            } else {
                false
            }
        });

        // Tab - Focus next
        let tab_cleanup = keyboard::on_key("Tab", || {
            // Check if shift is held via last_event
            let event = keyboard::last_event();
            if let Some(e) = event {
                if e.modifiers.shift {
                    return false; // Let shift+tab handler handle it
                }
            }
            focus::focus_next();
            true // Consume
        });

        // Shift+Tab - Focus previous
        // This needs to check modifiers in the handler
        let shift_tab_cleanup = keyboard::on(move |event| {
            if event.key == "Tab" && event.modifiers.shift {
                focus::focus_prev();
                true // Consume
            } else {
                false
            }
        });

        GlobalKeysHandle {
            ctrl_c_cleanup: Some(Box::new(ctrl_c_cleanup)),
            tab_cleanup: Some(Box::new(tab_cleanup)),
            shift_tab_cleanup: Some(Box::new(shift_tab_cleanup)),
        }
    }

    /// Clean up all global keys state (for testing).
    pub fn cleanup_global_keys() {
        // Nothing to clean up beyond the handle
    }
    ```

    Update `src/state/mod.rs` to add `pub mod global_keys;`
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    GlobalKeysHandle and setup_global_keys are exported.
  </verify>
  <done>
    global_keys.rs provides setup_global_keys function.
    Ctrl+C sets running to false.
    Tab calls focus_next.
    Shift+Tab calls focus_prev.
    Returns handle for cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate event loop into mount</name>
  <files>src/pipeline/mount.rs</files>
  <action>
    Update `src/pipeline/mount.rs`:

    1. **Add imports**:
       ```rust
       use crate::state::{input, global_keys};
       use std::time::Duration;
       ```

    2. **Update MountHandle** to include global keys handle:
       ```rust
       pub struct MountHandle {
           stop_effect: Option<Box<dyn FnOnce()>>,
           running: Arc<AtomicBool>,
           global_keys: Option<global_keys::GlobalKeysHandle>,
       }
       ```

    3. **Update mount() function**:

       After creating the render effect, before returning:
       ```rust
       // Enable mouse capture
       input::enable_mouse()?;

       // Set up global key handlers
       let global_keys_handle = global_keys::setup_global_keys(running.clone());
       ```

       Update the return:
       ```rust
       Ok(MountHandle {
           stop_effect: Some(stop),
           running,
           global_keys: Some(global_keys_handle),
       })
       ```

    4. **Add event loop function** (called externally or in a thread):
       ```rust
       /// Run the event loop once (non-blocking).
       /// Call this in your main loop.
       /// Returns false if should stop running.
       pub fn tick(handle: &MountHandle) -> io::Result<bool> {
           if !handle.is_running() {
               return Ok(false);
           }

           // Poll with short timeout (16ms ~ 60fps)
           if let Some(event) = input::poll_event(Duration::from_millis(16))? {
               input::route_event(event);
           }

           Ok(handle.is_running())
       }

       /// Run the event loop (blocking until stopped).
       pub fn run(handle: &MountHandle) -> io::Result<()> {
           while tick(handle)? {
               // Continue
           }
           Ok(())
       }
       ```

    5. **Update unmount to clean up mouse and global keys**:
       ```rust
       impl MountHandle {
           pub fn unmount(mut self) {
               self.running.store(false, Ordering::SeqCst);

               // Clean up global keys
               if let Some(handle) = self.global_keys.take() {
                   handle.cleanup();
               }

               // Disable mouse capture
               let _ = input::disable_mouse();

               // Stop render effect
               if let Some(stop) = self.stop_effect.take() {
                   stop();
               }
           }
       }
       ```

    6. **Update Drop impl**:
       ```rust
       impl Drop for MountHandle {
           fn drop(&mut self) {
               // Disable mouse on drop
               let _ = input::disable_mouse();

               if let Some(stop) = self.stop_effect.take() {
                   stop();
               }
           }
       }
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    tick() and run() functions are available.
  </verify>
  <done>
    mount() enables mouse capture.
    mount() sets up global key handlers.
    tick() polls and routes one event.
    run() loops until stopped.
    unmount() disables mouse and cleans up.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests and verify focus functions exist</name>
  <files>src/pipeline/mount.rs, src/state/focus.rs</files>
  <action>
    1. **Verify focus module has focus_next and focus_prev**:
       Check `src/state/focus.rs` for these functions. If they don't exist, add them:

       ```rust
       /// Focus the next focusable component in tab order.
       pub fn focus_next() {
           // Get all focusable components sorted by tab_index
           // Find current focused, move to next
           // If none focused or at end, focus first
           // Implementation follows TypeScript pattern
       }

       /// Focus the previous focusable component in tab order.
       pub fn focus_prev() {
           // Same as focus_next but reverse direction
       }
       ```

       (These may already exist - check first!)

    2. **Add tests to mount.rs** for the new functionality:
       ```rust
       #[cfg(test)]
       mod tests {
           use super::*;

           // Existing tests...

           #[test]
           fn test_mount_handle_is_running() {
               let running = Arc::new(AtomicBool::new(true));
               // Note: Can't fully test mount() in unit tests due to terminal dependency
               // But we can test the running flag logic
               assert!(running.load(Ordering::SeqCst));
               running.store(false, Ordering::SeqCst);
               assert!(!running.load(Ordering::SeqCst));
           }
       }
       ```

    3. **Add documentation** to public functions in mount.rs:
       ```rust
       /// Mount the TUI application.
       ///
       /// This sets up:
       /// 1. Terminal size detection
       /// 2. Reactive render pipeline
       /// 3. Mouse capture
       /// 4. Global key handlers (Ctrl+C, Tab)
       ///
       /// # Example
       ///
       /// ```ignore
       /// let handle = mount()?;
       ///
       /// // Option 1: Run blocking event loop
       /// run(&handle)?;
       ///
       /// // Option 2: Tick manually in your own loop
       /// while tick(&handle)? {
       ///     // Your logic here
       /// }
       ///
       /// // Clean up
       /// handle.unmount();
       /// ```
       ```
  </action>
  <verify>
    `cargo check -p spark-tui` compiles.
    `cargo test -p spark-tui -- --test-threads=1` passes.
    focus_next and focus_prev exist in focus module.
  </verify>
  <done>
    focus_next and focus_prev available.
    mount.rs has documentation.
    Basic tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p spark-tui` - No compile errors
2. `cargo test -p spark-tui -- --test-threads=1` - All tests pass
3. Verify mount enables mouse: `input::enable_mouse()` is called
4. Verify global keys: Ctrl+C, Tab, Shift+Tab handlers registered
5. Verify unmount cleans up: disables mouse, cleans handlers
</verification>

<success_criteria>
- mount() enables mouse capture on startup
- mount() registers global key handlers (Ctrl+C, Tab, Shift+Tab)
- tick() polls for input and dispatches via route_event
- run() provides blocking event loop
- Ctrl+C sets running to false for graceful shutdown
- Tab calls focus_next, Shift+Tab calls focus_prev
- unmount() disables mouse capture and cleans up handlers
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-mouse-events/01-04-SUMMARY.md`
</output>
