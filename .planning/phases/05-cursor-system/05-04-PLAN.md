---
phase: 05-cursor-system
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - src/pipeline/frame_buffer_derived.rs
autonomous: true

must_haves:
  truths:
    - "Cursor renders at correct position in Input"
    - "Block cursor shows text character with INVERSE"
    - "Bar and underline cursors render their special characters"
    - "Cursor only renders when focused AND visible"
    - "Selection renders with INVERSE highlighting"
  artifacts:
    - path: "src/pipeline/frame_buffer_derived.rs"
      provides: "Cursor and selection rendering in render_input"
      contains: "render_input_cursor"
  key_links:
    - from: "src/pipeline/frame_buffer_derived.rs"
      to: "src/state/focus.rs"
      via: "is_focused check"
      pattern: "focus::is_focused"
    - from: "src/pipeline/frame_buffer_derived.rs"
      to: "src/engine/arrays/interaction.rs"
      via: "cursor and selection state"
      pattern: "interaction::get_cursor"
---

<objective>
Implement cursor and selection rendering in the frame buffer.

Purpose: The visual cursor needs to be drawn into the FrameBuffer during render_input, accounting for scroll offset, selection highlighting, and cursor style.

Output: Updated `render_input()` function with cursor and selection rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cursor-system/05-CONTEXT.md
@.planning/phases/05-cursor-system/05-RESEARCH.md
@.planning/phases/05-cursor-system/05-03-SUMMARY.md
@src/pipeline/frame_buffer_derived.rs
@src/state/focus.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add selection rendering helper</name>
  <files>src/pipeline/frame_buffer_derived.rs</files>
  <action>
Add selection rendering function to `frame_buffer_derived.rs`:

```rust
/// Render selection highlighting for an input field.
///
/// Selection is rendered with INVERSE attribute (swap fg/bg).
fn render_input_selection(
    buffer: &mut FrameBuffer,
    index: usize,
    content_x: u16,
    content_y: u16,
    content_w: u16,
    text: &str,
    fg: Rgba,
    bg: Rgba,
    scroll_x: u16,
    clip: &ClipRect,
) {
    // Get selection range
    let sel_start = interaction::get_selection_start(index) as usize;
    let sel_end = interaction::get_selection_end(index) as usize;

    if sel_start >= sel_end {
        return; // No selection
    }

    let chars: Vec<char> = text.chars().collect();
    let scroll_x = scroll_x as usize;

    // Render each selected character
    for pos in sel_start..sel_end {
        let screen_pos = pos.saturating_sub(scroll_x);
        if screen_pos >= content_w as usize {
            break; // Off screen to the right
        }
        if pos < scroll_x {
            continue; // Off screen to the left
        }

        let render_x = content_x + screen_pos as u16;
        let ch = chars.get(pos).copied().unwrap_or(' ');

        // Draw with INVERSE (swap fg/bg for selection)
        buffer.set_cell(
            render_x,
            content_y,
            ch as u32,
            fg,  // Selection uses fg as bg
            bg,  // Selection uses bg as fg
            Attr::INVERSE,
            Some(clip),
        );
    }
}
```

Add necessary imports at top:
- `use crate::state::focus;`
  </action>
  <verify>
  ```bash
  cargo build -p spark-tui 2>&1 | head -30
  ```
  </verify>
  <done>
  - render_input_selection function exists
  - Selection renders with INVERSE attribute
  - Respects scroll offset
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cursor rendering helper</name>
  <files>src/pipeline/frame_buffer_derived.rs</files>
  <action>
Add cursor rendering function to `frame_buffer_derived.rs`:

```rust
/// Render cursor for an input field.
///
/// Only renders when:
/// 1. Input is focused
/// 2. Cursor is visible (respects blink state)
///
/// Cursor styles:
/// - Block (style=0): Render text char with INVERSE
/// - Bar (style=1): Render │ character
/// - Underline (style=2): Render _ character
fn render_input_cursor(
    buffer: &mut FrameBuffer,
    index: usize,
    content_x: u16,
    content_y: u16,
    content_w: u16,
    text: &str,
    fg: Rgba,
    bg: Rgba,
    scroll_x: u16,
    clip: &ClipRect,
) {
    // Only render cursor when focused
    if !focus::is_focused(index) {
        return;
    }

    // Check cursor visibility (respects blink state)
    if !interaction::get_cursor_visible(index) {
        return;
    }

    let cursor_pos = interaction::get_cursor_position(index) as usize;
    let scroll_x = scroll_x as usize;

    // Calculate screen position
    let screen_pos = cursor_pos.saturating_sub(scroll_x);
    if screen_pos >= content_w as usize {
        return; // Cursor off screen
    }

    let render_x = content_x + screen_pos as u16;

    // Get character at cursor position (or space if at end)
    let chars: Vec<char> = text.chars().collect();
    let char_at_cursor = chars.get(cursor_pos).copied().unwrap_or(' ');

    // Get cursor style (0=Block, 1=Bar, 2=Underline)
    let cursor_style = interaction::get_cursor_style(index);

    match cursor_style {
        0 => {
            // Block cursor: render character with INVERSE
            buffer.set_cell(
                render_x,
                content_y,
                char_at_cursor as u32,
                bg,  // Swap colors for inverse effect
                fg,
                Attr::INVERSE,
                Some(clip),
            );
        }
        1 => {
            // Bar cursor: render │ character at cursor position
            // First render the text character normally
            buffer.set_cell(
                render_x,
                content_y,
                char_at_cursor as u32,
                fg,
                bg,
                Attr::NONE,
                Some(clip),
            );
            // Then overlay the bar (this will be visible on left edge)
            // For a proper bar, we'd need half-character rendering
            // Compromise: show bar character
            buffer.set_cell(
                render_x,
                content_y,
                0x2502, // │
                fg,
                bg,
                Attr::NONE,
                Some(clip),
            );
        }
        2 => {
            // Underline cursor: render character with underline attribute
            buffer.set_cell(
                render_x,
                content_y,
                char_at_cursor as u32,
                fg,
                bg,
                Attr::UNDERLINE,
                Some(clip),
            );
        }
        _ => {
            // Custom cursor char - get from cursor_char array
            let cursor_char = interaction::get_cursor_char(index);
            if cursor_char == 0 {
                // 0 = block (inverse)
                buffer.set_cell(
                    render_x,
                    content_y,
                    char_at_cursor as u32,
                    bg,
                    fg,
                    Attr::INVERSE,
                    Some(clip),
                );
            } else {
                buffer.set_cell(
                    render_x,
                    content_y,
                    cursor_char,
                    fg,
                    bg,
                    Attr::NONE,
                    Some(clip),
                );
            }
        }
    }
}
```
  </action>
  <verify>
  ```bash
  cargo build -p spark-tui 2>&1 | head -30
  ```
  </verify>
  <done>
  - render_input_cursor function exists
  - Block cursor uses INVERSE
  - Bar cursor renders │
  - Underline cursor uses UNDERLINE attribute
  - Cursor only renders when focused AND visible
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into render_input</name>
  <files>src/pipeline/frame_buffer_derived.rs</files>
  <action>
Update the existing `render_input()` function to call the new helpers:

1. **Update render_input signature** to accept bg color:
   - Add `bg: Rgba` parameter (get from inheritance)

2. **Get scroll offset**:
   ```rust
   let scroll_x = interaction::get_scroll_offset_x(index);
   ```

3. **Render text with scroll offset**:
   - Adjust text display to account for scroll_x
   - Only show characters from scroll_x onwards

4. **After rendering text, render selection** (if any):
   ```rust
   render_input_selection(
       buffer, index, content_x, content_y, content_w,
       &display_text, fg, effective_bg, scroll_x, clip
   );
   ```

5. **After selection, render cursor**:
   ```rust
   render_input_cursor(
       buffer, index, content_x, content_y, content_w,
       &display_text, fg, effective_bg, scroll_x, clip
   );
   ```

6. **Update call site in render_component**:
   - Pass effective_bg to render_input

The order matters: text first, then selection overlay, then cursor on top.

Remove the `// TODO: Render cursor if focused` comment since it's now implemented.
  </action>
  <verify>
  ```bash
  cargo build -p spark-tui 2>&1 | head -30
  cargo test -p spark-tui frame_buffer --no-fail-fast 2>&1 | tail -30
  ```
  </verify>
  <done>
  - render_input calls render_input_selection and render_input_cursor
  - Text renders with scroll offset
  - Selection overlays text
  - Cursor overlays selection
  - Build and existing tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build -p spark-tui

# All frame_buffer tests pass
cargo test -p spark-tui frame_buffer --no-fail-fast

# Functions exist
grep -r "fn render_input_cursor" src/pipeline/frame_buffer_derived.rs
grep -r "fn render_input_selection" src/pipeline/frame_buffer_derived.rs
```
</verification>

<success_criteria>
- [ ] Selection renders with INVERSE highlighting
- [ ] Block cursor renders with INVERSE
- [ ] Bar cursor renders │ character
- [ ] Underline cursor uses UNDERLINE attribute
- [ ] Cursor only renders when focused AND visible
- [ ] Scroll offset respected for cursor position
- [ ] All tests pass
- [ ] No compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-cursor-system/05-04-SUMMARY.md`
</output>
