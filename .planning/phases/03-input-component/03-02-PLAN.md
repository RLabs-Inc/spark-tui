---
phase: 03-input-component
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/primitives/input.rs
autonomous: true

must_haves:
  truths:
    - "Ctrl+Left jumps cursor to previous word boundary"
    - "Ctrl+Right jumps cursor to next word boundary"
    - "Ctrl+Backspace deletes word before cursor"
    - "Ctrl+Delete deletes word after cursor"
    - "Ctrl+A selects all text (sets selection range)"
    - "Selection start/end stored in interaction arrays"
  artifacts:
    - path: "src/primitives/input.rs"
      provides: "Enhanced keyboard handling with word navigation"
      contains: "find_word_boundary"
    - path: "src/engine/arrays/interaction.rs"
      provides: "Selection arrays (already exists)"
      contains: "SELECTION_START"
  key_links:
    - from: "src/primitives/input.rs"
      to: "src/engine/arrays/interaction.rs"
      via: "selection state management"
      pattern: "interaction::set_selection"
---

<objective>
Add word-level navigation and deletion to Input component.

Purpose: Complete keyboard handling with Ctrl+Arrow word navigation and Ctrl+Backspace/Delete word deletion as specified in CONTEXT.md decisions.

Output:
- Word boundary detection functions
- Ctrl+Left/Right word navigation
- Ctrl+Backspace/Delete word deletion
- Ctrl+A select all
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-input-component/03-CONTEXT.md
@.planning/phases/03-input-component/03-01-SUMMARY.md

@src/primitives/input.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add word boundary detection helpers</name>
  <files>src/primitives/input.rs</files>
  <action>
Add helper functions at the top of the module (after the imports, before the input function):

```rust
// =============================================================================
// Word Boundary Helpers
// =============================================================================

/// Find the start of the word before the given position.
/// A word is defined as a sequence of alphanumeric characters.
fn find_word_start(text: &str, pos: usize) -> usize {
    if pos == 0 {
        return 0;
    }

    let chars: Vec<char> = text.chars().collect();
    let mut i = pos;

    // Skip whitespace going backward
    while i > 0 && !chars[i - 1].is_alphanumeric() {
        i -= 1;
    }

    // Skip word characters going backward
    while i > 0 && chars[i - 1].is_alphanumeric() {
        i -= 1;
    }

    i
}

/// Find the end of the word after the given position.
/// A word is defined as a sequence of alphanumeric characters.
fn find_word_end(text: &str, pos: usize) -> usize {
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();

    if pos >= len {
        return len;
    }

    let mut i = pos;

    // Skip whitespace going forward
    while i < len && !chars[i].is_alphanumeric() {
        i += 1;
    }

    // Skip word characters going forward
    while i < len && chars[i].is_alphanumeric() {
        i += 1;
    }

    i
}
```

These functions use character-based positions which work for ASCII. For Unicode, we're using char iteration which handles multi-byte correctly.
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
Word boundary detection helpers added for word navigation and deletion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance keyboard handler with word operations and Ctrl+A</name>
  <files>src/primitives/input.rs</files>
  <action>
Update the keyboard handler inside the input() function to handle Ctrl+Arrow, Ctrl+Backspace/Delete, and Ctrl+A.

Replace the keyboard handler closure with this enhanced version:

```rust
    let key_cleanup = keyboard::on_focused(index, move |event| {
        let val = value_for_key.get();
        let chars: Vec<char> = val.chars().collect();
        let char_len = chars.len();
        let pos = cursor_pos_for_key.borrow().get().min(char_len as u16) as usize;

        // Helper to update value (only works for Signal)
        let set_value = |new_val: String| {
            if let PropValue::Signal(ref s) = value_for_key {
                s.set(new_val);
            }
        };

        match event.key.as_str() {
            // Navigation
            "ArrowLeft" => {
                if event.modifiers.ctrl {
                    // Jump to word start
                    let new_pos = find_word_start(&val, pos);
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                } else if pos > 0 {
                    cursor_pos_for_key.borrow().set((pos - 1) as u16);
                }
                true
            }
            "ArrowRight" => {
                if event.modifiers.ctrl {
                    // Jump to word end
                    let new_pos = find_word_end(&val, pos);
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                } else if pos < char_len {
                    cursor_pos_for_key.borrow().set((pos + 1) as u16);
                }
                true
            }
            "Home" => {
                cursor_pos_for_key.borrow().set(0);
                true
            }
            "End" => {
                cursor_pos_for_key.borrow().set(char_len as u16);
                true
            }

            // Deletion
            "Backspace" => {
                if pos > 0 {
                    let delete_to = if event.modifiers.ctrl {
                        // Delete word before cursor
                        find_word_start(&val, pos)
                    } else {
                        pos - 1
                    };

                    // Build new string from chars (handles Unicode correctly)
                    let new_chars: String = chars[..delete_to]
                        .iter()
                        .chain(chars[pos..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    cursor_pos_for_key.borrow().set(delete_to as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                }
                true
            }
            "Delete" => {
                if pos < char_len {
                    let delete_to = if event.modifiers.ctrl {
                        // Delete word after cursor
                        find_word_end(&val, pos)
                    } else {
                        pos + 1
                    };

                    // Build new string from chars
                    let new_chars: String = chars[..pos]
                        .iter()
                        .chain(chars[delete_to..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                }
                true
            }

            // Select All (Ctrl+A)
            "a" | "A" if event.modifiers.ctrl => {
                // Set selection to entire text
                // Selection is stored in interaction arrays
                interaction::set_selection_start(index, 0);
                interaction::set_selection_end(index, char_len as u16);
                // Move cursor to end (common behavior)
                cursor_pos_for_key.borrow().set(char_len as u16);
                true
            }

            // Submission
            "Enter" => {
                if let Some(ref cb) = on_submit {
                    cb(&val);
                }
                true
            }

            // Cancel
            "Escape" => {
                if let Some(ref cb) = on_cancel {
                    cb();
                }
                true
            }

            // Character input
            key => {
                // Only single printable characters without Ctrl/Alt/Meta
                if key.len() == 1 && !event.modifiers.ctrl && !event.modifiers.alt && !event.modifiers.meta {
                    // Check max length
                    if let Some(max) = max_length {
                        if max > 0 && char_len >= max {
                            return true;
                        }
                    }

                    // Clear selection on new input
                    interaction::set_selection_start(index, 0);
                    interaction::set_selection_end(index, 0);

                    // Insert character at cursor position
                    let ch = key.chars().next().unwrap();
                    let new_chars: String = chars[..pos]
                        .iter()
                        .chain(std::iter::once(&ch))
                        .chain(chars[pos..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    cursor_pos_for_key.borrow().set((pos + 1) as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                    true
                } else {
                    false
                }
            }
        }
    });
```

Note: We need to add functions to interaction.rs for selection. Check if they exist, otherwise add them.
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
Keyboard handler enhanced with word navigation (Ctrl+Arrow), word deletion (Ctrl+Backspace/Delete), and select all (Ctrl+A).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add selection setters to interaction arrays and add tests</name>
  <files>
    src/engine/arrays/interaction.rs
    src/primitives/input.rs
  </files>
  <action>
First, check if set_selection_start/set_selection_end exist in interaction.rs. If not, add them:

```rust
// =============================================================================
// Selection
// =============================================================================

/// Set selection start at index.
pub fn set_selection_start(index: usize, pos: u16) {
    SELECTION_START.with(|arr| arr.set_value(index, pos));
}

/// Set selection end at index.
pub fn set_selection_end(index: usize, pos: u16) {
    SELECTION_END.with(|arr| arr.set_value(index, pos));
}

/// Get selection start at index.
pub fn get_selection_start(index: usize) -> u16 {
    SELECTION_START.with(|arr| arr.get(index))
}

/// Get selection end at index.
pub fn get_selection_end(index: usize) -> u16 {
    SELECTION_END.with(|arr| arr.get(index))
}
```

Then add tests for word operations in input.rs:

```rust
    #[test]
    fn test_word_boundary_helpers() {
        // Test find_word_start
        assert_eq!(find_word_start("hello world", 5), 0);  // At end of "hello"
        assert_eq!(find_word_start("hello world", 6), 0);  // At space
        assert_eq!(find_word_start("hello world", 11), 6); // At end of "world"
        assert_eq!(find_word_start("hello world", 7), 6);  // At 'w'
        assert_eq!(find_word_start("hello world", 0), 0);  // At start

        // Test find_word_end
        assert_eq!(find_word_end("hello world", 0), 5);  // At start
        assert_eq!(find_word_end("hello world", 5), 11); // At end of "hello"
        assert_eq!(find_word_end("hello world", 6), 11); // At space (before "world")
        assert_eq!(find_word_end("hello world", 11), 11); // At end
    }

    #[test]
    fn test_ctrl_arrow_word_navigation() {
        setup();

        let value = signal("hello world test".to_string());

        let _cleanup = input(InputProps {
            value: PropValue::Signal(value.clone()),
            auto_focus: true,
            ..Default::default()
        });

        // Initial cursor at 0
        assert_eq!(interaction::get_cursor_position(0), 0);

        // Simulate Ctrl+Right - should jump to end of "hello" (pos 5)
        // This would need keyboard dispatch which we test via the handler directly
    }

    #[test]
    fn test_ctrl_a_select_all() {
        setup();

        let value = signal("hello".to_string());

        let _cleanup = input(InputProps {
            value: PropValue::Signal(value.clone()),
            auto_focus: true,
            ..Default::default()
        });

        // Selection starts at 0,0 (nothing selected)
        assert_eq!(interaction::get_selection_start(0), 0);
        assert_eq!(interaction::get_selection_end(0), 0);

        // After Ctrl+A, selection should span entire text
        // Would need to dispatch keyboard event to test fully
    }
```
  </action>
  <verify>
`cargo test -p spark-tui` passes all tests including new word boundary tests.
  </verify>
  <done>
Selection setters added to interaction arrays, word boundary helpers tested, enhanced keyboard handling complete.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo check -p spark-tui` - No errors
2. `cargo test -p spark-tui` - All tests pass
3. Word boundary functions work correctly for edge cases

Manual verification (if running app):
- Ctrl+Left jumps to start of previous word
- Ctrl+Right jumps to end of next word
- Ctrl+Backspace deletes the word before cursor
- Ctrl+Delete deletes the word after cursor
- Ctrl+A selects all text
</verification>

<success_criteria>
- find_word_start() and find_word_end() helper functions exist
- Ctrl+Arrow word navigation works
- Ctrl+Backspace/Delete word deletion works
- Ctrl+A sets selection to entire text
- Selection stored in interaction arrays
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-component/03-02-SUMMARY.md`
</output>
