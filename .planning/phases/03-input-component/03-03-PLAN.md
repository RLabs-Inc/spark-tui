---
phase: 03-input-component
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/primitives/input.rs
  - src/state/clipboard.rs
  - src/state/mod.rs
autonomous: true

must_haves:
  truths:
    - "Shift+Left extends selection one character left"
    - "Shift+Right extends selection one character right"
    - "Shift+Ctrl+Left extends selection to previous word"
    - "Shift+Ctrl+Right extends selection to next word"
    - "Shift+Home extends selection to start"
    - "Shift+End extends selection to end"
    - "Ctrl+C copies selected text to clipboard"
    - "Ctrl+V pastes clipboard at cursor"
    - "Ctrl+X cuts selected text"
    - "Typing with selection replaces selected text"
  artifacts:
    - path: "src/state/clipboard.rs"
      provides: "Clipboard API"
      exports: ["copy", "paste", "cut"]
    - path: "src/primitives/input.rs"
      provides: "Selection handling and clipboard integration"
      contains: "has_selection"
  key_links:
    - from: "src/primitives/input.rs"
      to: "src/state/clipboard.rs"
      via: "clipboard operations on Ctrl+C/V/X"
      pattern: "clipboard::copy"
---

<objective>
Add text selection and clipboard support to Input component.

Purpose: Enable Shift+Arrow selection, word-level selection with Shift+Ctrl, and clipboard operations (Ctrl+C/V/X) as specified in CONTEXT.md decisions.

Output:
- Clipboard module with copy/paste/cut functions
- Shift+Arrow character selection
- Shift+Ctrl+Arrow word selection
- Clipboard integration in keyboard handler
- Selection replacement on typing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-input-component/03-CONTEXT.md
@.planning/phases/03-input-component/03-02-SUMMARY.md

@src/primitives/input.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clipboard module</name>
  <files>
    src/state/clipboard.rs
    src/state/mod.rs
  </files>
  <action>
Create src/state/clipboard.rs:

```rust
//! Clipboard Module - System clipboard access for copy/paste operations.
//!
//! Provides cross-platform clipboard access with fallback to internal buffer.
//!
//! # Example
//!
//! ```ignore
//! use spark_tui::state::clipboard;
//!
//! // Copy text
//! clipboard::copy("Hello, World!");
//!
//! // Paste text
//! if let Some(text) = clipboard::paste() {
//!     println!("Pasted: {}", text);
//! }
//! ```

use std::cell::RefCell;

// =============================================================================
// INTERNAL CLIPBOARD BUFFER (Fallback)
// =============================================================================

thread_local! {
    /// Internal clipboard buffer for when system clipboard is unavailable.
    static CLIPBOARD_BUFFER: RefCell<String> = RefCell::new(String::new());
}

// =============================================================================
// CLIPBOARD OPERATIONS
// =============================================================================

/// Copy text to the clipboard.
///
/// Tries system clipboard first, falls back to internal buffer.
pub fn copy(text: &str) {
    // Try system clipboard via arboard crate
    #[cfg(feature = "clipboard")]
    {
        if let Ok(mut clipboard) = arboard::Clipboard::new() {
            if clipboard.set_text(text).is_ok() {
                return;
            }
        }
    }

    // Fallback to internal buffer
    CLIPBOARD_BUFFER.with(|buf| {
        *buf.borrow_mut() = text.to_string();
    });
}

/// Paste text from the clipboard.
///
/// Tries system clipboard first, falls back to internal buffer.
/// Returns None if clipboard is empty.
pub fn paste() -> Option<String> {
    // Try system clipboard via arboard crate
    #[cfg(feature = "clipboard")]
    {
        if let Ok(mut clipboard) = arboard::Clipboard::new() {
            if let Ok(text) = clipboard.get_text() {
                if !text.is_empty() {
                    return Some(text);
                }
            }
        }
    }

    // Fallback to internal buffer
    CLIPBOARD_BUFFER.with(|buf| {
        let text = buf.borrow().clone();
        if text.is_empty() {
            None
        } else {
            Some(text)
        }
    })
}

/// Cut text - copies to clipboard and returns true if something was copied.
///
/// This is a convenience function. The actual text removal happens in the caller.
pub fn cut(text: &str) -> bool {
    if text.is_empty() {
        return false;
    }
    copy(text);
    true
}

/// Clear the internal clipboard buffer.
pub fn clear() {
    CLIPBOARD_BUFFER.with(|buf| {
        buf.borrow_mut().clear();
    });
}

/// Check if clipboard has content.
pub fn has_content() -> bool {
    paste().is_some()
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn setup() {
        clear();
    }

    #[test]
    fn test_copy_paste() {
        setup();

        copy("Hello, World!");
        assert_eq!(paste(), Some("Hello, World!".to_string()));
    }

    #[test]
    fn test_empty_clipboard() {
        setup();
        assert_eq!(paste(), None);
    }

    #[test]
    fn test_cut() {
        setup();

        assert!(cut("Test text"));
        assert_eq!(paste(), Some("Test text".to_string()));

        assert!(!cut(""));
    }

    #[test]
    fn test_has_content() {
        setup();

        assert!(!has_content());
        copy("Something");
        assert!(has_content());
    }

    #[test]
    fn test_clear() {
        setup();

        copy("Text");
        assert!(has_content());
        clear();
        assert!(!has_content());
    }
}
```

Update src/state/mod.rs to export clipboard:

Add after the existing module declarations:
```rust
pub mod clipboard;
```

Note: The clipboard module uses an internal buffer by default. For system clipboard support, users can enable the `clipboard` feature and add `arboard` dependency. This is intentionally feature-gated to avoid pulling in heavy dependencies by default.
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
`cargo test -p spark-tui clipboard` passes.
  </verify>
  <done>
Clipboard module created with copy/paste/cut functions and internal buffer fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add selection helpers and update keyboard handler</name>
  <files>src/primitives/input.rs</files>
  <action>
Add the clipboard import at the top:
```rust
use crate::state::clipboard;
```

Add selection helper functions after the word boundary helpers:

```rust
// =============================================================================
// Selection Helpers
// =============================================================================

/// Check if there is an active selection.
fn has_selection(index: usize) -> bool {
    let start = interaction::get_selection_start(index);
    let end = interaction::get_selection_end(index);
    start != end
}

/// Get selected text from value.
fn get_selected_text(value: &str, index: usize) -> String {
    let start = interaction::get_selection_start(index) as usize;
    let end = interaction::get_selection_end(index) as usize;

    if start == end {
        return String::new();
    }

    let chars: Vec<char> = value.chars().collect();
    let (from, to) = if start < end { (start, end) } else { (end, start) };
    let from = from.min(chars.len());
    let to = to.min(chars.len());

    chars[from..to].iter().collect()
}

/// Clear selection.
fn clear_selection(index: usize) {
    interaction::set_selection_start(index, 0);
    interaction::set_selection_end(index, 0);
}

/// Delete selected text and return new value with cursor position.
fn delete_selection(value: &str, index: usize) -> (String, usize) {
    let start = interaction::get_selection_start(index) as usize;
    let end = interaction::get_selection_end(index) as usize;

    if start == end {
        return (value.to_string(), start);
    }

    let chars: Vec<char> = value.chars().collect();
    let (from, to) = if start < end { (start, end) } else { (end, start) };
    let from = from.min(chars.len());
    let to = to.min(chars.len());

    let new_chars: String = chars[..from]
        .iter()
        .chain(chars[to..].iter())
        .collect();

    clear_selection(index);
    (new_chars, from)
}
```

Now update the keyboard handler to support:
1. Shift+Arrow selection
2. Shift+Ctrl+Arrow word selection
3. Shift+Home/End selection
4. Ctrl+C copy
5. Ctrl+V paste
6. Ctrl+X cut
7. Replace selection on typing

Replace the keyboard handler closure with this enhanced version:

```rust
    let key_cleanup = keyboard::on_focused(index, move |event| {
        let val = value_for_key.get();
        let chars: Vec<char> = val.chars().collect();
        let char_len = chars.len();
        let pos = cursor_pos_for_key.borrow().get().min(char_len as u16) as usize;

        // Helper to update value (only works for Signal)
        let set_value = |new_val: String| {
            if let PropValue::Signal(ref s) = value_for_key {
                s.set(new_val);
            }
        };

        // Helper to update selection anchor for shift-selection
        let update_selection = |new_pos: usize, shift: bool| {
            if shift {
                // Extend selection
                let sel_start = interaction::get_selection_start(index);
                let sel_end = interaction::get_selection_end(index);

                if sel_start == sel_end {
                    // Start new selection from current cursor
                    interaction::set_selection_start(index, pos as u16);
                    interaction::set_selection_end(index, new_pos as u16);
                } else {
                    // Extend existing selection
                    interaction::set_selection_end(index, new_pos as u16);
                }
            } else {
                // Clear selection on non-shift movement
                clear_selection(index);
            }
            cursor_pos_for_key.borrow().set(new_pos as u16);
        };

        match event.key.as_str() {
            // Navigation with optional selection
            "ArrowLeft" => {
                let new_pos = if event.modifiers.ctrl {
                    find_word_start(&val, pos)
                } else if pos > 0 {
                    pos - 1
                } else {
                    pos
                };
                update_selection(new_pos, event.modifiers.shift);
                true
            }
            "ArrowRight" => {
                let new_pos = if event.modifiers.ctrl {
                    find_word_end(&val, pos)
                } else if pos < char_len {
                    pos + 1
                } else {
                    pos
                };
                update_selection(new_pos, event.modifiers.shift);
                true
            }
            "Home" => {
                update_selection(0, event.modifiers.shift);
                true
            }
            "End" => {
                update_selection(char_len, event.modifiers.shift);
                true
            }

            // Deletion
            "Backspace" => {
                if has_selection(index) {
                    // Delete selection
                    let (new_val, new_pos) = delete_selection(&val, index);
                    set_value(new_val.clone());
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                } else if pos > 0 {
                    let delete_to = if event.modifiers.ctrl {
                        find_word_start(&val, pos)
                    } else {
                        pos - 1
                    };

                    let new_chars: String = chars[..delete_to]
                        .iter()
                        .chain(chars[pos..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    cursor_pos_for_key.borrow().set(delete_to as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                }
                true
            }
            "Delete" => {
                if has_selection(index) {
                    let (new_val, new_pos) = delete_selection(&val, index);
                    set_value(new_val.clone());
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                } else if pos < char_len {
                    let delete_to = if event.modifiers.ctrl {
                        find_word_end(&val, pos)
                    } else {
                        pos + 1
                    };

                    let new_chars: String = chars[..pos]
                        .iter()
                        .chain(chars[delete_to..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                }
                true
            }

            // Select All (Ctrl+A)
            "a" | "A" if event.modifiers.ctrl && !event.modifiers.shift => {
                interaction::set_selection_start(index, 0);
                interaction::set_selection_end(index, char_len as u16);
                cursor_pos_for_key.borrow().set(char_len as u16);
                true
            }

            // Copy (Ctrl+C)
            "c" | "C" if event.modifiers.ctrl && !event.modifiers.shift => {
                if has_selection(index) {
                    let selected = get_selected_text(&val, index);
                    clipboard::copy(&selected);
                }
                true
            }

            // Paste (Ctrl+V)
            "v" | "V" if event.modifiers.ctrl && !event.modifiers.shift => {
                if let Some(paste_text) = clipboard::paste() {
                    // Delete selection first if any
                    let (base_val, insert_pos) = if has_selection(index) {
                        delete_selection(&val, index)
                    } else {
                        (val.clone(), pos)
                    };

                    // Check max length
                    let paste_chars: Vec<char> = paste_text.chars().collect();
                    let base_chars: Vec<char> = base_val.chars().collect();
                    let allowed_len = if let Some(max) = max_length {
                        if max > 0 {
                            max.saturating_sub(base_chars.len())
                        } else {
                            paste_chars.len()
                        }
                    } else {
                        paste_chars.len()
                    };

                    let paste_chars: Vec<char> = paste_chars.into_iter().take(allowed_len).collect();

                    // Insert paste text
                    let new_chars: String = base_chars[..insert_pos]
                        .iter()
                        .chain(paste_chars.iter())
                        .chain(base_chars[insert_pos..].iter())
                        .collect();

                    let new_pos = insert_pos + paste_chars.len();
                    set_value(new_chars.clone());
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                }
                true
            }

            // Cut (Ctrl+X)
            "x" | "X" if event.modifiers.ctrl && !event.modifiers.shift => {
                if has_selection(index) {
                    let selected = get_selected_text(&val, index);
                    clipboard::cut(&selected);
                    let (new_val, new_pos) = delete_selection(&val, index);
                    set_value(new_val.clone());
                    cursor_pos_for_key.borrow().set(new_pos as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                }
                true
            }

            // Submission
            "Enter" => {
                if let Some(ref cb) = on_submit {
                    cb(&val);
                }
                true
            }

            // Cancel
            "Escape" => {
                if let Some(ref cb) = on_cancel {
                    cb();
                }
                true
            }

            // Character input
            key => {
                // Only single printable characters without Ctrl/Alt/Meta
                if key.len() == 1 && !event.modifiers.ctrl && !event.modifiers.alt && !event.modifiers.meta {
                    // Delete selection first if any
                    let (base_val, insert_pos) = if has_selection(index) {
                        delete_selection(&val, index)
                    } else {
                        (val.clone(), pos)
                    };

                    let base_chars: Vec<char> = base_val.chars().collect();

                    // Check max length
                    if let Some(max) = max_length {
                        if max > 0 && base_chars.len() >= max {
                            return true;
                        }
                    }

                    // Insert character at cursor position
                    let ch = key.chars().next().unwrap();
                    let new_chars: String = base_chars[..insert_pos]
                        .iter()
                        .chain(std::iter::once(&ch))
                        .chain(base_chars[insert_pos..].iter())
                        .collect();

                    set_value(new_chars.clone());
                    cursor_pos_for_key.borrow().set((insert_pos + 1) as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_chars);
                    }
                    true
                } else {
                    false
                }
            }
        }
    });
```
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
Keyboard handler updated with selection support and clipboard operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add selection and clipboard tests</name>
  <files>src/primitives/input.rs</files>
  <action>
Add tests for selection and clipboard functionality:

```rust
    #[test]
    fn test_selection_helpers() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("hello world".to_string()),
            ..Default::default()
        });

        // No selection initially
        assert!(!has_selection(0));
        assert_eq!(get_selected_text("hello world", 0), "");

        // Set selection
        interaction::set_selection_start(0, 0);
        interaction::set_selection_end(0, 5);
        assert!(has_selection(0));
        assert_eq!(get_selected_text("hello world", 0), "hello");

        // Clear selection
        clear_selection(0);
        assert!(!has_selection(0));
    }

    #[test]
    fn test_delete_selection() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("hello world".to_string()),
            ..Default::default()
        });

        // Select "hello "
        interaction::set_selection_start(0, 0);
        interaction::set_selection_end(0, 6);

        let (new_val, new_pos) = delete_selection("hello world", 0);
        assert_eq!(new_val, "world");
        assert_eq!(new_pos, 0);
    }

    #[test]
    fn test_clipboard_integration() {
        setup();
        clipboard::clear();

        // Copy
        clipboard::copy("test");
        assert_eq!(clipboard::paste(), Some("test".to_string()));

        // Cut
        clipboard::cut("cut text");
        assert_eq!(clipboard::paste(), Some("cut text".to_string()));
    }
```
  </action>
  <verify>
`cargo test -p spark-tui` passes all tests.
  </verify>
  <done>
Tests added for selection helpers and clipboard integration.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo check -p spark-tui` - No errors
2. `cargo test -p spark-tui` - All tests pass
3. `cargo test -p spark-tui clipboard` - Clipboard tests pass
4. `cargo test -p spark-tui selection` - Selection tests pass

Manual verification (if running app):
- Shift+Left/Right selects characters
- Shift+Ctrl+Left/Right selects words
- Shift+Home/End selects to boundaries
- Ctrl+C copies selection
- Ctrl+V pastes at cursor
- Ctrl+X cuts selection
- Typing replaces selection
</verification>

<success_criteria>
- Clipboard module exists with copy/paste/cut functions
- Shift+Arrow character selection works
- Shift+Ctrl+Arrow word selection works
- Shift+Home/End boundary selection works
- Ctrl+C copies selected text
- Ctrl+V pastes at cursor (or replaces selection)
- Ctrl+X cuts selected text
- Typing with selection replaces selection
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-component/03-03-SUMMARY.md`
</output>
