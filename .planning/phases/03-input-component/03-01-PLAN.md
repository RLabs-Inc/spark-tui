---
phase: 03-input-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/primitives/types.rs
  - src/primitives/input.rs
  - src/primitives/mod.rs
  - src/types.rs
autonomous: true

must_haves:
  truths:
    - "InputProps struct exists with all required fields"
    - "CursorStyle enum exists with Block, Bar, Underline variants"
    - "Input component allocates index and sets up core arrays"
    - "Input displays value or placeholder appropriately"
    - "Input masks characters in password mode"
    - "Input cleanup function releases resources"
  artifacts:
    - path: "src/types.rs"
      provides: "CursorStyle enum"
      contains: "pub enum CursorStyle"
    - path: "src/primitives/types.rs"
      provides: "InputProps struct, InputCallback types"
      contains: "pub struct InputProps"
    - path: "src/primitives/input.rs"
      provides: "input() component function"
      exports: ["input"]
    - path: "src/primitives/mod.rs"
      provides: "input module export"
      contains: "pub use input::input"
  key_links:
    - from: "src/primitives/input.rs"
      to: "src/engine/arrays/text.rs"
      via: "set_text_content_getter for display text"
      pattern: "text_arrays::set_text_content_getter"
    - from: "src/primitives/input.rs"
      to: "src/engine/arrays/interaction.rs"
      via: "set_focusable, set_cursor_position"
      pattern: "interaction::set_focusable"
---

<objective>
Create Input component foundation with props, types, and basic rendering.

Purpose: Establish the Input primitive structure that subsequent plans will build keyboard handling, selection, and advanced features onto.

Output:
- CursorStyle enum in types.rs
- InputProps struct in primitives/types.rs
- input() function that displays value/placeholder with password masking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-input-component/03-CONTEXT.md

@src/primitives/box_primitive.rs
@src/primitives/text.rs
@src/primitives/types.rs
@src/types.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CursorStyle enum and Input callbacks to types</name>
  <files>
    src/types.rs
    src/primitives/types.rs
  </files>
  <action>
Add to src/types.rs after TextWrap enum:

```rust
/// Cursor style for input components.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
#[repr(u8)]
pub enum CursorStyle {
    #[default]
    Block = 0,
    Bar = 1,
    Underline = 2,
}
```

Add to src/primitives/types.rs:

1. Add imports at top:
```rust
use crate::types::CursorStyle;
```

2. Add callback type aliases after KeyCallback:
```rust
/// Input value change callback.
pub type InputChangeCallback = Rc<dyn Fn(&str)>;

/// Input submit callback (Enter key).
pub type InputSubmitCallback = Rc<dyn Fn(&str)>;

/// Input cancel callback (Escape key).
pub type InputCancelCallback = Rc<dyn Fn()>;
```

3. Add BlinkConfig struct before InputProps:
```rust
/// Cursor blink configuration.
#[derive(Debug, Clone)]
pub struct BlinkConfig {
    /// Enable blink (default: true).
    pub enabled: bool,
    /// Blink rate in FPS (default: 2 = 500ms cycle).
    pub fps: u8,
    /// Character to show on "off" phase (default: space).
    pub alt_char: Option<char>,
}

impl Default for BlinkConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            fps: 2,
            alt_char: None,
        }
    }
}

/// Cursor configuration for Input component.
#[derive(Debug, Clone, Default)]
pub struct CursorConfig {
    /// Cursor shape: Block, Bar, or Underline.
    pub style: Option<CursorStyle>,
    /// Custom cursor character (overrides style preset).
    pub char: Option<char>,
    /// Blink configuration.
    pub blink: Option<BlinkConfig>,
    /// Custom cursor foreground color.
    pub fg: Option<PropValue<Rgba>>,
    /// Custom cursor background color.
    pub bg: Option<PropValue<Rgba>>,
}
```

4. Add InputProps struct after TextProps:
```rust
/// Properties for the Input component.
///
/// Input is a single-line text entry component with full editing capabilities.
///
/// # Example
///
/// ```ignore
/// use spark_tui::primitives::{input, InputProps};
/// use spark_signals::signal;
///
/// let name = signal(String::new());
///
/// let cleanup = input(InputProps {
///     value: name.clone().into(),
///     placeholder: Some("Enter your name...".to_string()),
///     on_submit: Some(Rc::new(|val| println!("Submitted: {}", val))),
///     ..Default::default()
/// });
/// ```
pub struct InputProps {
    // =========================================================================
    // Identity
    // =========================================================================

    /// Optional component ID for lookup.
    pub id: Option<String>,

    // =========================================================================
    // Value - REQUIRED
    // =========================================================================

    /// Current value (two-way bound via Signal).
    pub value: PropValue<String>,

    // =========================================================================
    // Visibility
    // =========================================================================

    /// Whether the component is visible (default: true).
    pub visible: Option<PropValue<bool>>,

    // =========================================================================
    // Placeholder
    // =========================================================================

    /// Placeholder text shown when value is empty.
    pub placeholder: Option<String>,

    /// Placeholder color (default: fgMuted from theme).
    pub placeholder_color: Option<PropValue<Rgba>>,

    // =========================================================================
    // Password Mode
    // =========================================================================

    /// Enable password masking.
    pub password: bool,

    /// Password mask character (default: '●').
    pub mask_char: Option<char>,

    // =========================================================================
    // Text Styling
    // =========================================================================

    /// Text attributes (bold, italic, etc.).
    pub attrs: Option<PropValue<Attr>>,

    /// Text alignment (left, center, right).
    pub align: Option<PropValue<TextAlign>>,

    // =========================================================================
    // Cursor
    // =========================================================================

    /// Cursor configuration.
    pub cursor: Option<CursorConfig>,

    // =========================================================================
    // Constraints
    // =========================================================================

    /// Maximum input length (0 = unlimited).
    pub max_length: Option<usize>,

    /// Auto-focus on mount.
    pub auto_focus: bool,

    // =========================================================================
    // Layout - Dimensions
    // =========================================================================

    /// Width.
    pub width: Option<PropValue<Dimension>>,

    /// Height.
    pub height: Option<PropValue<Dimension>>,

    /// Minimum width.
    pub min_width: Option<PropValue<Dimension>>,

    /// Maximum width.
    pub max_width: Option<PropValue<Dimension>>,

    /// Minimum height.
    pub min_height: Option<PropValue<Dimension>>,

    /// Maximum height.
    pub max_height: Option<PropValue<Dimension>>,

    // =========================================================================
    // Spacing
    // =========================================================================

    /// Padding (all sides).
    pub padding: Option<PropValue<u16>>,

    /// Padding top.
    pub padding_top: Option<PropValue<u16>>,

    /// Padding right.
    pub padding_right: Option<PropValue<u16>>,

    /// Padding bottom.
    pub padding_bottom: Option<PropValue<u16>>,

    /// Padding left.
    pub padding_left: Option<PropValue<u16>>,

    /// Margin (all sides).
    pub margin: Option<PropValue<u16>>,

    /// Margin top.
    pub margin_top: Option<PropValue<u16>>,

    /// Margin right.
    pub margin_right: Option<PropValue<u16>>,

    /// Margin bottom.
    pub margin_bottom: Option<PropValue<u16>>,

    /// Margin left.
    pub margin_left: Option<PropValue<u16>>,

    // =========================================================================
    // Border
    // =========================================================================

    /// Border style (all sides).
    pub border: Option<PropValue<BorderStyle>>,

    /// Border color.
    pub border_color: Option<PropValue<Rgba>>,

    // =========================================================================
    // Visual
    // =========================================================================

    /// Foreground color.
    pub fg: Option<PropValue<Rgba>>,

    /// Background color.
    pub bg: Option<PropValue<Rgba>>,

    /// Opacity (0-255).
    pub opacity: Option<PropValue<u8>>,

    // =========================================================================
    // Interaction
    // =========================================================================

    /// Tab index for focus navigation.
    pub tab_index: Option<i32>,

    // =========================================================================
    // Event Callbacks
    // =========================================================================

    /// Called when value changes.
    pub on_change: Option<InputChangeCallback>,

    /// Called on Enter key.
    pub on_submit: Option<InputSubmitCallback>,

    /// Called on Escape key.
    pub on_cancel: Option<InputCancelCallback>,

    /// Called on focus.
    pub on_focus: Option<Box<dyn Fn()>>,

    /// Called on blur.
    pub on_blur: Option<Box<dyn Fn()>>,

    /// Click callback.
    pub on_click: Option<MouseCallback>,

    /// Mouse down callback.
    pub on_mouse_down: Option<MouseCallback>,

    /// Mouse up callback.
    pub on_mouse_up: Option<MouseCallback>,

    /// Mouse enter callback.
    pub on_mouse_enter: Option<MouseCallback>,

    /// Mouse leave callback.
    pub on_mouse_leave: Option<MouseCallback>,
}

impl Default for InputProps {
    fn default() -> Self {
        Self {
            id: None,
            value: PropValue::Static(String::new()),
            visible: None,
            placeholder: None,
            placeholder_color: None,
            password: false,
            mask_char: None,
            attrs: None,
            align: None,
            cursor: None,
            max_length: None,
            auto_focus: false,
            width: None,
            height: None,
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None,
            padding: None,
            padding_top: None,
            padding_right: None,
            padding_bottom: None,
            padding_left: None,
            margin: None,
            margin_top: None,
            margin_right: None,
            margin_bottom: None,
            margin_left: None,
            border: None,
            border_color: None,
            fg: None,
            bg: None,
            opacity: None,
            tab_index: None,
            on_change: None,
            on_submit: None,
            on_cancel: None,
            on_focus: None,
            on_blur: None,
            on_click: None,
            on_mouse_down: None,
            on_mouse_up: None,
            on_mouse_enter: None,
            on_mouse_leave: None,
        }
    }
}
```

Don't forget to add TextAlign import at top of primitives/types.rs if not present.
  </action>
  <verify>
`cargo check -p spark-tui` succeeds with no errors.
  </verify>
  <done>
CursorStyle enum in types.rs, InputProps struct with all fields in primitives/types.rs, BlinkConfig and CursorConfig structs for cursor customization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Input component with basic rendering</name>
  <files>
    src/primitives/input.rs
    src/primitives/mod.rs
  </files>
  <action>
Create src/primitives/input.rs:

```rust
//! Input Primitive - Single-line text entry component.
//!
//! Features:
//! - Two-way value binding via signals
//! - Placeholder text when empty
//! - Password mode with masking
//! - Cursor position tracking
//! - Full border and styling support
//!
//! # Example
//!
//! ```ignore
//! use spark_tui::primitives::{input, InputProps};
//! use spark_signals::signal;
//!
//! let name = signal(String::new());
//!
//! let cleanup = input(InputProps {
//!     value: name.clone().into(),
//!     placeholder: Some("Enter your name...".to_string()),
//!     ..Default::default()
//! });
//! ```

use std::cell::RefCell;
use std::rc::Rc;

use spark_signals::signal;

use crate::engine::{
    allocate_index, release_index, create_flex_node,
    get_current_parent_index,
};
use crate::engine::arrays::{core, visual, text as text_arrays, interaction};
use crate::state::{mouse, keyboard, focus};
use crate::types::{ComponentType, BorderStyle};
use super::types::{InputProps, PropValue, Cleanup};

// =============================================================================
// Helper: Bind PropValue to Slot
// =============================================================================

macro_rules! bind_slot {
    ($slot:expr, $prop:expr) => {
        match $prop {
            PropValue::Static(v) => $slot.set_value(v),
            PropValue::Signal(s) => $slot.set_signal(s),
            PropValue::Getter(g) => $slot.set_signal_readonly(move || g()),
        }
    };
}

// =============================================================================
// Input Component
// =============================================================================

/// Create a single-line text input component.
///
/// Inputs are always focusable. When focused, they handle keyboard input
/// for text editing.
///
/// # Value Binding
///
/// The `value` prop supports two-way binding:
/// - `PropValue::Signal(signal)` - Changes update the signal
/// - `PropValue::Static(string)` - Initial value only (uncontrolled)
///
/// # Password Mode
///
/// Set `password: true` to mask characters with the mask character (default: '●').
///
/// Returns a cleanup function that releases resources when called.
pub fn input(props: InputProps) -> Cleanup {
    // 1. ALLOCATE INDEX
    let index = allocate_index(props.id.as_deref());

    // 2. CREATE FLEXNODE
    let flex_node = create_flex_node(index);

    // 3. CORE SETUP
    core::set_component_type(index, ComponentType::Input);
    if let Some(parent) = get_current_parent_index() {
        core::set_parent_index(index, Some(parent));
    }

    // 4. VISIBILITY
    if let Some(visible) = props.visible {
        match visible {
            PropValue::Static(v) => core::set_visible(index, v),
            PropValue::Signal(s) => core::set_visible_signal(index, s),
            PropValue::Getter(g) => core::set_visible_getter(index, move || g()),
        }
    }

    // 5. INTERNAL STATE
    // Local cursor position signal
    let cursor_pos = Rc::new(RefCell::new(signal(0u16)));

    // Password mask character
    let mask_char = props.mask_char.unwrap_or('●');

    // Clone value prop for use in closures
    let value_prop = props.value.clone();
    let placeholder = props.placeholder.clone();
    let password = props.password;

    // 6. TEXT CONTENT - Display text via getter
    // Shows placeholder when empty, masks when password mode
    let value_for_display = value_prop.clone();
    let placeholder_for_display = placeholder.clone();
    text_arrays::set_text_content_getter(index, move || {
        let val = value_for_display.get();
        if val.is_empty() {
            placeholder_for_display.clone().unwrap_or_default()
        } else if password {
            mask_char.to_string().repeat(val.len())
        } else {
            val
        }
    });

    // 7. TEXT STYLING
    if let Some(attrs) = props.attrs {
        match attrs {
            PropValue::Static(v) => text_arrays::set_text_attrs(index, v),
            PropValue::Signal(s) => text_arrays::set_text_attrs_getter(index, move || s.get()),
            PropValue::Getter(g) => text_arrays::set_text_attrs_getter(index, move || g()),
        }
    }

    if let Some(align) = props.align {
        match align {
            PropValue::Static(v) => text_arrays::set_text_align(index, v),
            PropValue::Signal(s) => text_arrays::set_text_align_getter(index, move || s.get()),
            PropValue::Getter(g) => text_arrays::set_text_align_getter(index, move || g()),
        }
    }

    // 8. FLEXNODE BINDINGS - Dimensions
    if let Some(w) = props.width {
        bind_slot!(flex_node.width, w);
    }
    if let Some(h) = props.height {
        bind_slot!(flex_node.height, h);
    }
    if let Some(min_w) = props.min_width {
        bind_slot!(flex_node.min_width, min_w);
    }
    if let Some(max_w) = props.max_width {
        bind_slot!(flex_node.max_width, max_w);
    }
    if let Some(min_h) = props.min_height {
        bind_slot!(flex_node.min_height, min_h);
    }
    if let Some(max_h) = props.max_height {
        bind_slot!(flex_node.max_height, max_h);
    }

    // Spacing - Padding
    if let Some(ref p) = props.padding {
        if props.padding_top.is_none() {
            bind_slot!(flex_node.padding_top, p.clone());
        }
        if props.padding_right.is_none() {
            bind_slot!(flex_node.padding_right, p.clone());
        }
        if props.padding_bottom.is_none() {
            bind_slot!(flex_node.padding_bottom, p.clone());
        }
        if props.padding_left.is_none() {
            bind_slot!(flex_node.padding_left, p.clone());
        }
    }
    if let Some(pt) = props.padding_top {
        bind_slot!(flex_node.padding_top, pt);
    }
    if let Some(pr) = props.padding_right {
        bind_slot!(flex_node.padding_right, pr);
    }
    if let Some(pb) = props.padding_bottom {
        bind_slot!(flex_node.padding_bottom, pb);
    }
    if let Some(pl) = props.padding_left {
        bind_slot!(flex_node.padding_left, pl);
    }

    // Spacing - Margin
    if let Some(ref m) = props.margin {
        if props.margin_top.is_none() {
            bind_slot!(flex_node.margin_top, m.clone());
        }
        if props.margin_right.is_none() {
            bind_slot!(flex_node.margin_right, m.clone());
        }
        if props.margin_bottom.is_none() {
            bind_slot!(flex_node.margin_bottom, m.clone());
        }
        if props.margin_left.is_none() {
            bind_slot!(flex_node.margin_left, m.clone());
        }
    }
    if let Some(mt) = props.margin_top {
        bind_slot!(flex_node.margin_top, mt);
    }
    if let Some(mr) = props.margin_right {
        bind_slot!(flex_node.margin_right, mr);
    }
    if let Some(mb) = props.margin_bottom {
        bind_slot!(flex_node.margin_bottom, mb);
    }
    if let Some(ml) = props.margin_left {
        bind_slot!(flex_node.margin_left, ml);
    }

    // 9. BORDER
    if let Some(ref border) = props.border {
        match border {
            PropValue::Static(style) => {
                let has_border = *style != BorderStyle::None;
                flex_node.border_top.set_value(if has_border { 1 } else { 0 });
                flex_node.border_right.set_value(if has_border { 1 } else { 0 });
                flex_node.border_bottom.set_value(if has_border { 1 } else { 0 });
                flex_node.border_left.set_value(if has_border { 1 } else { 0 });
                visual::set_border_style(index, *style);
            }
            PropValue::Signal(s) => {
                let s_clone = s.clone();
                flex_node.border_top.set_signal_readonly(move || {
                    if s_clone.get() != BorderStyle::None { 1 } else { 0 }
                });
                let s_clone = s.clone();
                flex_node.border_right.set_signal_readonly(move || {
                    if s_clone.get() != BorderStyle::None { 1 } else { 0 }
                });
                let s_clone = s.clone();
                flex_node.border_bottom.set_signal_readonly(move || {
                    if s_clone.get() != BorderStyle::None { 1 } else { 0 }
                });
                let s_clone = s.clone();
                flex_node.border_left.set_signal_readonly(move || {
                    if s_clone.get() != BorderStyle::None { 1 } else { 0 }
                });
                visual::set_border_style_getter(index, move || s.get());
            }
            PropValue::Getter(g) => {
                let g_clone = g.clone();
                flex_node.border_top.set_signal_readonly(move || {
                    if g_clone() != BorderStyle::None { 1 } else { 0 }
                });
                let g_clone = g.clone();
                flex_node.border_right.set_signal_readonly(move || {
                    if g_clone() != BorderStyle::None { 1 } else { 0 }
                });
                let g_clone = g.clone();
                flex_node.border_bottom.set_signal_readonly(move || {
                    if g_clone() != BorderStyle::None { 1 } else { 0 }
                });
                let g_clone = g.clone();
                flex_node.border_left.set_signal_readonly(move || {
                    if g_clone() != BorderStyle::None { 1 } else { 0 }
                });
                visual::set_border_style_getter(index, move || g());
            }
        }
    }

    if let Some(bc) = props.border_color {
        match bc {
            PropValue::Static(v) => visual::set_border_color(index, v),
            PropValue::Signal(s) => visual::set_border_color_getter(index, move || s.get()),
            PropValue::Getter(g) => visual::set_border_color_getter(index, move || g()),
        }
    }

    // 10. VISUAL - Colors
    if let Some(fg) = props.fg {
        match fg {
            PropValue::Static(v) => visual::set_fg_color(index, v),
            PropValue::Signal(s) => visual::set_fg_color_getter(index, move || s.get()),
            PropValue::Getter(g) => visual::set_fg_color_getter(index, move || g()),
        }
    }

    if let Some(bg) = props.bg {
        match bg {
            PropValue::Static(v) => visual::set_bg_color(index, v),
            PropValue::Signal(s) => visual::set_bg_color_getter(index, move || s.get()),
            PropValue::Getter(g) => visual::set_bg_color_getter(index, move || g()),
        }
    }

    if let Some(opacity) = props.opacity {
        match opacity {
            PropValue::Static(v) => visual::set_opacity(index, v),
            PropValue::Signal(s) => visual::set_opacity(index, s.get()),
            PropValue::Getter(g) => visual::set_opacity(index, g()),
        }
    }

    // 11. FOCUS - Inputs are ALWAYS focusable
    interaction::set_focusable(index, true);
    if let Some(tab_idx) = props.tab_index {
        interaction::set_tab_index(index, tab_idx);
    }

    // 12. CURSOR POSITION - Reactive getter clamped to value length
    let value_for_cursor = value_prop.clone();
    let cursor_pos_for_getter = cursor_pos.clone();
    interaction::set_cursor_position_getter(index, move || {
        let pos = cursor_pos_for_getter.borrow().get();
        let len = value_for_cursor.get().len() as u16;
        pos.min(len)
    });

    // 13. MOUSE HANDLERS - Click-to-focus
    let user_on_click = props.on_click.clone();
    let click_handler: Rc<dyn Fn(&mouse::MouseEvent)> = Rc::new(move |event: &mouse::MouseEvent| {
        focus::focus(index);
        if let Some(ref handler) = user_on_click {
            handler(event);
        }
    });

    let handlers = mouse::MouseHandlers {
        on_mouse_down: props.on_mouse_down.clone(),
        on_mouse_up: props.on_mouse_up.clone(),
        on_click: Some(click_handler),
        on_mouse_enter: props.on_mouse_enter.clone(),
        on_mouse_leave: props.on_mouse_leave.clone(),
        on_scroll: None,
    };

    let mouse_cleanup = mouse::on_component(index, handlers);

    // 14. FOCUS CALLBACKS
    let focus_cleanup = if props.on_focus.is_some() || props.on_blur.is_some() {
        Some(focus::register_callbacks(index, focus::FocusCallbacks {
            on_focus: props.on_focus,
            on_blur: props.on_blur,
        }))
    } else {
        None
    };

    // 15. KEYBOARD HANDLER - Placeholder for now, full implementation in Plan 02
    // Just handle basic character input and events
    let value_for_key = props.value.clone();
    let cursor_pos_for_key = cursor_pos.clone();
    let on_change = props.on_change.clone();
    let on_submit = props.on_submit.clone();
    let on_cancel = props.on_cancel.clone();
    let max_length = props.max_length;

    let key_cleanup = keyboard::on_focused(index, move |event| {
        let val = value_for_key.get();
        let pos = cursor_pos_for_key.borrow().get().min(val.len() as u16) as usize;

        match event.key.as_str() {
            // Navigation
            "ArrowLeft" => {
                if pos > 0 {
                    cursor_pos_for_key.borrow().set((pos - 1) as u16);
                }
                true
            }
            "ArrowRight" => {
                if pos < val.len() {
                    cursor_pos_for_key.borrow().set((pos + 1) as u16);
                }
                true
            }
            "Home" => {
                cursor_pos_for_key.borrow().set(0);
                true
            }
            "End" => {
                cursor_pos_for_key.borrow().set(val.len() as u16);
                true
            }
            // Deletion
            "Backspace" => {
                if pos > 0 {
                    let new_val = format!("{}{}", &val[..pos - 1], &val[pos..]);
                    if let PropValue::Signal(ref s) = value_for_key {
                        s.set(new_val.clone());
                    }
                    cursor_pos_for_key.borrow().set((pos - 1) as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                }
                true
            }
            "Delete" => {
                if pos < val.len() {
                    let new_val = format!("{}{}", &val[..pos], &val[pos + 1..]);
                    if let PropValue::Signal(ref s) = value_for_key {
                        s.set(new_val.clone());
                    }
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                }
                true
            }
            // Submission
            "Enter" => {
                if let Some(ref cb) = on_submit {
                    cb(&val);
                }
                true
            }
            // Cancel
            "Escape" => {
                if let Some(ref cb) = on_cancel {
                    cb();
                }
                true
            }
            // Character input
            key => {
                // Only single printable characters without Ctrl/Alt/Meta
                if key.len() == 1 && !event.modifiers.ctrl && !event.modifiers.alt && !event.modifiers.meta {
                    // Check max length
                    if let Some(max) = max_length {
                        if max > 0 && val.len() >= max {
                            return true;
                        }
                    }
                    let new_val = format!("{}{}{}", &val[..pos], key, &val[pos..]);
                    if let PropValue::Signal(ref s) = value_for_key {
                        s.set(new_val.clone());
                    }
                    cursor_pos_for_key.borrow().set((pos + 1) as u16);
                    if let Some(ref cb) = on_change {
                        cb(&new_val);
                    }
                    true
                } else {
                    false
                }
            }
        }
    });

    // 16. AUTO-FOCUS
    if props.auto_focus {
        focus::focus(index);
    }

    // 17. CLEANUP
    Box::new(move || {
        mouse_cleanup();
        key_cleanup();
        if let Some(cleanup) = focus_cleanup {
            cleanup();
        }
        mouse::cleanup_index(index);
        keyboard::cleanup_index(index);
        release_index(index);
    })
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::engine::reset_registry;
    use crate::state::focus::reset_focus_state;
    use spark_signals::signal;

    fn setup() {
        reset_registry();
        reset_focus_state();
    }

    #[test]
    fn test_input_creation() {
        setup();

        let cleanup = input(InputProps {
            value: PropValue::Static("Hello".to_string()),
            ..Default::default()
        });

        assert_eq!(core::get_component_type(0), ComponentType::Input);
        assert!(interaction::get_focusable(0));

        cleanup();
        assert_eq!(core::get_component_type(0), ComponentType::None);
    }

    #[test]
    fn test_input_displays_value() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("Test".to_string()),
            ..Default::default()
        });

        assert_eq!(text_arrays::get_text_content(0), "Test");
    }

    #[test]
    fn test_input_displays_placeholder_when_empty() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static(String::new()),
            placeholder: Some("Enter text...".to_string()),
            ..Default::default()
        });

        assert_eq!(text_arrays::get_text_content(0), "Enter text...");
    }

    #[test]
    fn test_input_password_masking() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("secret".to_string()),
            password: true,
            ..Default::default()
        });

        // 6 characters masked with default mask char
        assert_eq!(text_arrays::get_text_content(0), "●●●●●●");
    }

    #[test]
    fn test_input_custom_mask_char() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("test".to_string()),
            password: true,
            mask_char: Some('*'),
            ..Default::default()
        });

        assert_eq!(text_arrays::get_text_content(0), "****");
    }

    #[test]
    fn test_input_reactive_value() {
        setup();

        let value = signal("Initial".to_string());

        let _cleanup = input(InputProps {
            value: PropValue::Signal(value.clone()),
            ..Default::default()
        });

        assert_eq!(text_arrays::get_text_content(0), "Initial");

        value.set("Updated".to_string());
        assert_eq!(text_arrays::get_text_content(0), "Updated");
    }

    #[test]
    fn test_input_auto_focus() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static(String::new()),
            auto_focus: true,
            ..Default::default()
        });

        assert!(focus::is_focused(0));
    }

    #[test]
    fn test_input_cursor_position() {
        setup();

        let _cleanup = input(InputProps {
            value: PropValue::Static("Hello".to_string()),
            ..Default::default()
        });

        // Initial cursor position is 0
        assert_eq!(interaction::get_cursor_position(0), 0);
    }
}
```

Update src/primitives/mod.rs to export input:

Add after the text module:
```rust
pub mod input;
pub use input::input;
```

And update the pub use statement at the top to include InputProps, CursorConfig, BlinkConfig:
```rust
pub use types::{BoxProps, TextProps, InputProps, PropValue, Cleanup, CursorConfig, BlinkConfig};
```
  </action>
  <verify>
`cargo test -p spark-tui input` runs and all input tests pass.
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
Input component created with basic rendering, value binding, placeholder, password masking, and basic keyboard handling (arrows, home/end, backspace/delete, character input).
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. `cargo check -p spark-tui` - No errors
2. `cargo test -p spark-tui` - All tests pass
3. `cargo test -p spark-tui input` - All input-specific tests pass (7+ tests)

The Input component should:
- Display value text or placeholder when empty
- Mask characters in password mode
- Be always focusable
- Handle basic keyboard navigation and editing
- Support reactive value binding
- Clean up properly when unmounted
</verification>

<success_criteria>
- CursorStyle enum exists in src/types.rs
- InputProps struct exists with all documented fields
- input() function creates component at allocated index
- Component displays value, placeholder, or masked text appropriately
- Component is always focusable
- Basic keyboard handling works (arrows, home/end, backspace, delete, char input)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-component/03-01-SUMMARY.md`
</output>
