---
phase: 03-input-component
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/primitives/input.rs
  - src/primitives/types.rs
autonomous: true

must_haves:
  truths:
    - "Up arrow recalls previous history entry"
    - "Down arrow recalls next history entry"
    - "History can be user-provided or auto-tracked"
    - "Long text shows overflow indicators (< >) at edges"
    - "Cursor is always visible when text overflows"
    - "Scroll offset adjusts to keep cursor in view"
  artifacts:
    - path: "src/primitives/types.rs"
      provides: "InputHistory type and history prop"
      contains: "pub history"
    - path: "src/primitives/input.rs"
      provides: "History navigation and overflow handling"
      contains: "handle_history"
  key_links:
    - from: "src/primitives/input.rs"
      to: "src/engine/arrays/interaction.rs"
      via: "scroll_offset for text scrolling"
      pattern: "interaction::set_scroll_offset"
---

<objective>
Add input history and text overflow handling to Input component.

Purpose: Complete Input component with history navigation (Up/Down arrows) and visual feedback for text that extends beyond the input width, as specified in CONTEXT.md decisions.

Output:
- InputHistory struct for managing history
- Up/Down arrow history navigation
- Text scroll offset for overflow
- Visual overflow indicators (< >) concept (actual rendering in Phase 5/Cursor)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-input-component/03-CONTEXT.md
@.planning/phases/03-input-component/03-03-SUMMARY.md

@src/primitives/input.rs
@src/primitives/types.rs
@src/engine/arrays/interaction.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InputHistory type and history props</name>
  <files>src/primitives/types.rs</files>
  <action>
Add InputHistory struct and related types before InputProps:

```rust
/// Input history mode.
#[derive(Debug, Clone, Default)]
pub enum HistoryMode {
    /// No history.
    #[default]
    None,
    /// Auto-track history (stores submitted values).
    Auto,
    /// User-provided history.
    Provided(Vec<String>),
}

/// Input history state for Up/Down navigation.
#[derive(Debug, Clone)]
pub struct InputHistory {
    /// History entries (oldest first).
    pub entries: Vec<String>,
    /// Current position in history (-1 = not in history, editing new).
    pub position: i32,
    /// Maximum history entries to keep.
    pub max_entries: usize,
    /// Value being edited before entering history.
    pub editing_value: Option<String>,
}

impl Default for InputHistory {
    fn default() -> Self {
        Self {
            entries: Vec::new(),
            position: -1,
            max_entries: 100,
            editing_value: None,
        }
    }
}

impl InputHistory {
    /// Create a new history with the given entries.
    pub fn new(entries: Vec<String>) -> Self {
        Self {
            entries,
            position: -1,
            max_entries: 100,
            editing_value: None,
        }
    }

    /// Create a new empty history with auto-tracking.
    pub fn auto() -> Self {
        Self::default()
    }

    /// Add an entry to history.
    pub fn push(&mut self, entry: String) {
        // Don't add duplicates of the most recent entry
        if self.entries.last().map(|s| s.as_str()) == Some(&entry) {
            return;
        }
        // Don't add empty entries
        if entry.is_empty() {
            return;
        }
        self.entries.push(entry);
        // Trim to max size
        while self.entries.len() > self.max_entries {
            self.entries.remove(0);
        }
        // Reset position
        self.position = -1;
        self.editing_value = None;
    }

    /// Move up in history (older).
    /// Returns the entry to display, or None if at boundary.
    pub fn up(&mut self, current_value: &str) -> Option<&str> {
        if self.entries.is_empty() {
            return None;
        }

        if self.position == -1 {
            // Save current editing value
            self.editing_value = Some(current_value.to_string());
            self.position = self.entries.len() as i32 - 1;
            Some(&self.entries[self.position as usize])
        } else if self.position > 0 {
            self.position -= 1;
            Some(&self.entries[self.position as usize])
        } else {
            None // At oldest entry
        }
    }

    /// Move down in history (newer).
    /// Returns the entry to display, or None if back to editing.
    pub fn down(&mut self) -> Option<String> {
        if self.position == -1 {
            return None; // Not in history
        }

        if self.position < self.entries.len() as i32 - 1 {
            self.position += 1;
            Some(self.entries[self.position as usize].clone())
        } else {
            // Return to editing
            self.position = -1;
            self.editing_value.take()
        }
    }

    /// Reset history position (called when value changes).
    pub fn reset_position(&mut self) {
        self.position = -1;
        self.editing_value = None;
    }

    /// Check if currently browsing history.
    pub fn is_browsing(&self) -> bool {
        self.position >= 0
    }
}
```

Add history prop to InputProps (add after `auto_focus`):

```rust
    /// Input history for Up/Down navigation.
    /// - None: No history
    /// - Some(history): Enable history navigation
    pub history: Option<Rc<RefCell<InputHistory>>>,
```

Also add the import at the top of types.rs:
```rust
use std::cell::RefCell;
```
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
InputHistory type with navigation methods and history prop added to InputProps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add history navigation to keyboard handler</name>
  <files>src/primitives/input.rs</files>
  <action>
Update the keyboard handler to handle Up/Down arrows for history navigation.

First, clone the history prop for the closure:
```rust
    let history = props.history.clone();
```

Then update the keyboard handler to add cases for ArrowUp and ArrowDown:

Add these cases after ArrowRight and before Home:

```rust
            // History navigation
            "ArrowUp" => {
                if let Some(ref hist) = history {
                    let current = value_for_key.get();
                    if let Some(entry) = hist.borrow_mut().up(&current) {
                        let entry_owned = entry.to_string();
                        if let PropValue::Signal(ref s) = value_for_key {
                            s.set(entry_owned.clone());
                        }
                        // Move cursor to end
                        cursor_pos_for_key.borrow().set(entry_owned.len() as u16);
                        clear_selection(index);
                    }
                }
                true
            }
            "ArrowDown" => {
                if let Some(ref hist) = history {
                    if let Some(entry) = hist.borrow_mut().down() {
                        if let PropValue::Signal(ref s) = value_for_key {
                            s.set(entry.clone());
                        }
                        // Move cursor to end
                        cursor_pos_for_key.borrow().set(entry.len() as u16);
                        clear_selection(index);
                    }
                }
                true
            }
```

Also, update the Enter handler to add to history if auto-tracking:

```rust
            // Submission
            "Enter" => {
                // Add to history if tracking
                if let Some(ref hist) = history {
                    hist.borrow_mut().push(val.clone());
                }
                if let Some(ref cb) = on_submit {
                    cb(&val);
                }
                true
            }
```

And reset history position when value changes (add to character input and paste handlers):

```rust
                    // Reset history position on edit
                    if let Some(ref hist) = history {
                        hist.borrow_mut().reset_position();
                    }
```
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
History navigation via Up/Down arrows implemented, auto-tracking on submit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add scroll offset tracking for cursor visibility</name>
  <files>src/primitives/input.rs</files>
  <action>
Add scroll offset state to keep cursor visible in overflow scenarios.

After the cursor_pos signal creation, add scroll offset state:

```rust
    // Scroll offset for text that extends beyond visible width
    let scroll_offset = Rc::new(RefCell::new(signal(0u16)));
```

Update the cursor position getter to also consider scroll offset:

```rust
    // Cursor position getter that tracks scroll
    let value_for_cursor = value_prop.clone();
    let cursor_pos_for_getter = cursor_pos.clone();
    let scroll_offset_for_getter = scroll_offset.clone();

    // Store scroll offset in interaction arrays for rendering to use
    interaction::set_scroll_offset(index, 0, 0);
```

Add a helper function to adjust scroll offset based on cursor position.
This is called whenever cursor moves:

```rust
/// Adjust scroll offset to keep cursor visible.
/// Returns the new scroll offset X.
fn ensure_cursor_visible(
    cursor_pos: usize,
    text_len: usize,
    scroll_offset: u16,
    visible_width: u16,
) -> u16 {
    // For now, we use a simple heuristic since we don't have actual component width
    // This will be refined when integrating with layout system
    let visible_width = if visible_width == 0 { 40 } else { visible_width };

    let cursor_in_view_start = scroll_offset as usize;
    let cursor_in_view_end = cursor_in_view_start + visible_width as usize;

    if cursor_pos < cursor_in_view_start {
        // Cursor is before visible area - scroll left
        cursor_pos as u16
    } else if cursor_pos >= cursor_in_view_end {
        // Cursor is after visible area - scroll right
        (cursor_pos - visible_width as usize + 1).max(0) as u16
    } else {
        // Cursor is visible - no change
        scroll_offset
    }
}
```

Update cursor movement code to call this helper and update scroll offset.
Add after each place where cursor position changes:

```rust
                    // Update scroll offset to keep cursor visible
                    let new_scroll = ensure_cursor_visible(
                        new_pos,
                        char_len,
                        scroll_offset_for_key.borrow().get(),
                        0, // Width comes from layout, 0 = use default
                    );
                    scroll_offset_for_key.borrow().set(new_scroll);
                    interaction::set_scroll_offset(index, new_scroll, 0);
```

Note: Full scroll offset integration with rendering happens in Phase 5 (Cursor System) when we implement the drawn cursor and visual overflow indicators. For now, we track the offset in the interaction arrays so the renderer can use it.
  </action>
  <verify>
`cargo check -p spark-tui` succeeds.
  </verify>
  <done>
Scroll offset tracking added to keep cursor visible when text overflows.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add history and overflow tests</name>
  <files>src/primitives/input.rs</files>
  <action>
Add comprehensive tests for history navigation:

```rust
    #[test]
    fn test_input_history_navigation() {
        let mut history = InputHistory::new(vec![
            "first".to_string(),
            "second".to_string(),
            "third".to_string(),
        ]);

        // Navigate up
        assert_eq!(history.up("current"), Some("third"));
        assert_eq!(history.up("current"), Some("second"));
        assert_eq!(history.up("current"), Some("first"));
        assert_eq!(history.up("current"), None); // At boundary

        // Navigate down
        assert_eq!(history.down(), Some("second".to_string()));
        assert_eq!(history.down(), Some("third".to_string()));
        assert_eq!(history.down(), Some("current".to_string())); // Back to editing value
        assert_eq!(history.down(), None); // Not in history
    }

    #[test]
    fn test_input_history_push() {
        let mut history = InputHistory::default();

        history.push("first".to_string());
        history.push("second".to_string());

        assert_eq!(history.entries, vec!["first", "second"]);

        // Don't add duplicates of last entry
        history.push("second".to_string());
        assert_eq!(history.entries, vec!["first", "second"]);

        // Don't add empty
        history.push(String::new());
        assert_eq!(history.entries, vec!["first", "second"]);
    }

    #[test]
    fn test_input_history_reset() {
        let mut history = InputHistory::new(vec!["old".to_string()]);

        // Enter history
        history.up("current");
        assert!(history.is_browsing());

        // Reset
        history.reset_position();
        assert!(!history.is_browsing());
    }

    #[test]
    fn test_ensure_cursor_visible() {
        // Cursor at start, no scroll needed
        assert_eq!(ensure_cursor_visible(0, 100, 0, 40), 0);

        // Cursor in view, no change
        assert_eq!(ensure_cursor_visible(20, 100, 0, 40), 0);

        // Cursor past end of view, scroll right
        assert_eq!(ensure_cursor_visible(50, 100, 0, 40), 11);

        // Cursor before view, scroll left
        assert_eq!(ensure_cursor_visible(5, 100, 20, 40), 5);
    }

    #[test]
    fn test_input_with_history() {
        setup();

        let history = Rc::new(RefCell::new(InputHistory::default()));
        let value = signal(String::new());

        let _cleanup = input(InputProps {
            value: PropValue::Signal(value.clone()),
            history: Some(history.clone()),
            auto_focus: true,
            ..Default::default()
        });

        // Add some history entries
        history.borrow_mut().push("command1".to_string());
        history.borrow_mut().push("command2".to_string());

        // History should have 2 entries
        assert_eq!(history.borrow().entries.len(), 2);
    }
```

Import Rc and RefCell at the top of the test module if not already imported:
```rust
    use std::rc::Rc;
    use std::cell::RefCell;
    use super::InputHistory;
```
  </action>
  <verify>
`cargo test -p spark-tui` passes all tests including history tests.
  </verify>
  <done>
History navigation and scroll offset tests added and passing.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo check -p spark-tui` - No errors
2. `cargo test -p spark-tui` - All tests pass
3. `cargo test -p spark-tui history` - History tests pass

Manual verification (if running app):
- Up arrow recalls previous history entry
- Down arrow recalls next history entry
- Entering history saves current editing value
- Returning from history restores editing value
- Submitting adds to history (if auto-tracking)
- Scroll offset keeps cursor in view
</verification>

<success_criteria>
- InputHistory type exists with navigation methods
- history prop added to InputProps
- Up/Down arrows navigate history
- Submit adds to history (auto-tracking)
- Scroll offset tracked in interaction arrays
- ensure_cursor_visible helper works correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-component/03-04-SUMMARY.md`
</output>
