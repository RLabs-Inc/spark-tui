//! Reactive theme state management.
//!
//! Uses ReactiveTheme (generated by #[derive(Reactive)]) for fine-grained
//! per-color reactivity. Changing one color only notifies deriveds that
//! read that specific color.

use std::cell::RefCell;
use super::{ReactiveTheme, Theme, terminal};

thread_local! {
    /// The active theme - each field is a Signal<ThemeColor>.
    /// Fine-grained: changing primary only notifies primary dependents.
    static ACTIVE_THEME: RefCell<ReactiveTheme> = RefCell::new(
        ReactiveTheme::from_original(terminal())
    );
}

/// Get a snapshot of the current theme (non-reactive).
pub fn active_theme() -> Theme {
    ACTIVE_THEME.with(|t| t.borrow().to_snapshot())
}

/// Get the reactive theme for creating deriveds.
/// Returns a clone of ReactiveTheme (Signal clones are cheap).
pub fn reactive_theme() -> ReactiveTheme {
    ACTIVE_THEME.with(|t| t.borrow().clone())
}

/// Set the active theme by preset name.
/// Copies each color from preset to the reactive signals.
pub fn set_theme(name: &str) {
    if let Some(preset) = super::get_preset(name) {
        set_theme_from(preset);
    }
}

/// Set a custom theme.
pub fn set_custom_theme(theme: Theme) {
    set_theme_from(theme);
}

/// Internal: copy theme values to ReactiveTheme signals.
fn set_theme_from(theme: Theme) {
    ACTIVE_THEME.with(|t| {
        let rt = t.borrow();
        rt.name.set(theme.name);
        rt.description.set(theme.description);
        rt.primary.set(theme.primary);
        rt.secondary.set(theme.secondary);
        rt.tertiary.set(theme.tertiary);
        rt.accent.set(theme.accent);
        rt.success.set(theme.success);
        rt.warning.set(theme.warning);
        rt.error.set(theme.error);
        rt.info.set(theme.info);
        rt.text.set(theme.text);
        rt.text_muted.set(theme.text_muted);
        rt.text_dim.set(theme.text_dim);
        rt.text_disabled.set(theme.text_disabled);
        rt.text_bright.set(theme.text_bright);
        rt.background.set(theme.background);
        rt.background_muted.set(theme.background_muted);
        rt.surface.set(theme.surface);
        rt.overlay.set(theme.overlay);
        rt.border.set(theme.border);
        rt.border_focus.set(theme.border_focus);
    });
}

/// Reset theme state to terminal (for testing).
pub fn reset_theme_state() {
    set_theme_from(terminal());
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::theme::ThemeColor;
    use crate::types::Rgba;
    use spark_signals::effect;
    use std::cell::Cell;
    use std::rc::Rc;

    #[test]
    fn test_default_theme_is_terminal() {
        reset_theme_state();
        assert_eq!(active_theme().name, "terminal");
    }

    #[test]
    fn test_set_theme_by_name() {
        reset_theme_state();
        set_theme("dracula");
        assert_eq!(active_theme().name, "dracula");
        reset_theme_state();
    }

    #[test]
    fn test_set_custom_theme() {
        reset_theme_state();
        let custom = Theme {
            name: "custom".into(),
            primary: ThemeColor::Rgb(Rgba::RED),
            ..terminal()
        };
        set_custom_theme(custom);
        assert_eq!(active_theme().name, "custom");
        reset_theme_state();
    }

    #[test]
    fn test_reactive_theme_signals_independent() {
        reset_theme_state();
        let rt = reactive_theme();

        // Track how many times primary effect runs
        let primary_count = Rc::new(Cell::new(0));
        let count = primary_count.clone();
        let primary = rt.primary.clone();
        let _e1 = effect(move || {
            let _ = primary.get();
            count.set(count.get() + 1);
        });

        // Track how many times secondary effect runs
        let secondary_count = Rc::new(Cell::new(0));
        let count2 = secondary_count.clone();
        let secondary = rt.secondary.clone();
        let _e2 = effect(move || {
            let _ = secondary.get();
            count2.set(count2.get() + 1);
        });

        // Initial runs
        assert_eq!(primary_count.get(), 1);
        assert_eq!(secondary_count.get(), 1);

        // Change only primary
        rt.primary.set(ThemeColor::Rgb(Rgba::RED));

        // Only primary effect should re-run!
        assert_eq!(primary_count.get(), 2);
        assert_eq!(secondary_count.get(), 1); // Still 1!

        reset_theme_state();
    }
}
