//! Reactive theme state management.
//!
//! Uses ReactiveTheme (generated by #[derive(Reactive)]) for fine-grained
//! per-color reactivity. Changing one color only notifies deriveds that
//! read that specific color.

use std::cell::RefCell;
use super::{ReactiveTheme, Theme, terminal};
use crate::types::Rgba;

// =============================================================================
// ResolvedTheme - All colors resolved to Rgba
// =============================================================================

/// Theme with all colors resolved to Rgba.
///
/// This is the resolved form of a Theme where all ThemeColor values
/// have been converted to concrete Rgba values.
#[derive(Debug, Clone, Copy)]
pub struct ResolvedTheme {
    // Main palette
    pub primary: Rgba,
    pub secondary: Rgba,
    pub tertiary: Rgba,
    pub accent: Rgba,

    // Semantic
    pub success: Rgba,
    pub warning: Rgba,
    pub error: Rgba,
    pub info: Rgba,

    // Text
    pub text: Rgba,
    pub text_muted: Rgba,
    pub text_dim: Rgba,
    pub text_disabled: Rgba,
    pub text_bright: Rgba,

    // Background
    pub background: Rgba,
    pub background_muted: Rgba,
    pub surface: Rgba,
    pub overlay: Rgba,

    // Border
    pub border: Rgba,
    pub border_focus: Rgba,
}

thread_local! {
    /// The active theme - each field is a Signal<ThemeColor>.
    /// Fine-grained: changing primary only notifies primary dependents.
    static ACTIVE_THEME: RefCell<ReactiveTheme> = RefCell::new(
        ReactiveTheme::from_original(terminal())
    );
}

/// Get a snapshot of the current theme (non-reactive).
pub fn active_theme() -> Theme {
    ACTIVE_THEME.with(|t| t.borrow().to_snapshot())
}

/// Get the reactive theme for creating deriveds.
/// Returns a clone of ReactiveTheme (Signal clones are cheap).
pub fn get_reactive_theme() -> ReactiveTheme {
    ACTIVE_THEME.with(|t| t.borrow().clone())
}

/// Set the active theme by preset name.
/// Copies each color from preset to the reactive signals.
pub fn set_theme(name: &str) {
    if let Some(preset) = super::get_preset(name) {
        set_theme_from(preset);
    }
}

/// Set a custom theme.
pub fn set_custom_theme(theme: Theme) {
    set_theme_from(theme);
}

/// Internal: copy theme values to ReactiveTheme signals.
fn set_theme_from(theme: Theme) {
    ACTIVE_THEME.with(|t| {
        let rt = t.borrow();
        rt.name.set(theme.name);
        rt.description.set(theme.description);
        rt.primary.set(theme.primary);
        rt.secondary.set(theme.secondary);
        rt.tertiary.set(theme.tertiary);
        rt.accent.set(theme.accent);
        rt.success.set(theme.success);
        rt.warning.set(theme.warning);
        rt.error.set(theme.error);
        rt.info.set(theme.info);
        rt.text.set(theme.text);
        rt.text_muted.set(theme.text_muted);
        rt.text_dim.set(theme.text_dim);
        rt.text_disabled.set(theme.text_disabled);
        rt.text_bright.set(theme.text_bright);
        rt.background.set(theme.background);
        rt.background_muted.set(theme.background_muted);
        rt.surface.set(theme.surface);
        rt.overlay.set(theme.overlay);
        rt.border.set(theme.border);
        rt.border_focus.set(theme.border_focus);
    });
}

/// Reset theme state to terminal (for testing).
pub fn reset_theme_state() {
    set_theme_from(terminal());
}

/// Get the current theme with all colors resolved to Rgba.
///
/// This function reads the current reactive theme and resolves all
/// ThemeColor values to concrete Rgba values. It tracks dependencies
/// on all color signals when called within a reactive context.
pub fn resolved_theme() -> ResolvedTheme {
    ACTIVE_THEME.with(|t| {
        let rt = t.borrow();
        ResolvedTheme {
            primary: rt.primary.get().resolve(),
            secondary: rt.secondary.get().resolve(),
            tertiary: rt.tertiary.get().resolve(),
            accent: rt.accent.get().resolve(),
            success: rt.success.get().resolve(),
            warning: rt.warning.get().resolve(),
            error: rt.error.get().resolve(),
            info: rt.info.get().resolve(),
            text: rt.text.get().resolve(),
            text_muted: rt.text_muted.get().resolve(),
            text_dim: rt.text_dim.get().resolve(),
            text_disabled: rt.text_disabled.get().resolve(),
            text_bright: rt.text_bright.get().resolve(),
            background: rt.background.get().resolve(),
            background_muted: rt.background_muted.get().resolve(),
            surface: rt.surface.get().resolve(),
            overlay: rt.overlay.get().resolve(),
            border: rt.border.get().resolve(),
            border_focus: rt.border_focus.get().resolve(),
        }
    })
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::theme::ThemeColor;
    use crate::types::Rgba;
    use spark_signals::effect;
    use std::cell::Cell;
    use std::rc::Rc;

    #[test]
    fn test_default_theme_is_terminal() {
        reset_theme_state();
        assert_eq!(active_theme().name, "terminal");
    }

    #[test]
    fn test_set_theme_by_name() {
        reset_theme_state();
        set_theme("dracula");
        assert_eq!(active_theme().name, "dracula");
        reset_theme_state();
    }

    #[test]
    fn test_set_custom_theme() {
        reset_theme_state();
        let custom = Theme {
            name: "custom".into(),
            primary: ThemeColor::Rgb(Rgba::RED),
            ..terminal()
        };
        set_custom_theme(custom);
        assert_eq!(active_theme().name, "custom");
        reset_theme_state();
    }

    #[test]
    fn test_reactive_theme_signals_independent() {
        reset_theme_state();
        let rt = get_reactive_theme();

        // Track how many times primary effect runs
        let primary_count = Rc::new(Cell::new(0));
        let count = primary_count.clone();
        let primary = rt.primary.clone();
        let _e1 = effect(move || {
            let _ = primary.get();
            count.set(count.get() + 1);
        });

        // Track how many times secondary effect runs
        let secondary_count = Rc::new(Cell::new(0));
        let count2 = secondary_count.clone();
        let secondary = rt.secondary.clone();
        let _e2 = effect(move || {
            let _ = secondary.get();
            count2.set(count2.get() + 1);
        });

        // Initial runs
        assert_eq!(primary_count.get(), 1);
        assert_eq!(secondary_count.get(), 1);

        // Change only primary
        rt.primary.set(ThemeColor::Rgb(Rgba::RED));

        // Only primary effect should re-run!
        assert_eq!(primary_count.get(), 2);
        assert_eq!(secondary_count.get(), 1); // Still 1!

        reset_theme_state();
    }
}
